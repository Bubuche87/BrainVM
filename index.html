<!doctype html>
<html>
  <head>
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="js.css" />
    <link rel="stylesheet" href="glsl.css" />
    <script src="btree.js"></script>
    <script src="js_colorizer.js"></script>
    <script src="glsl_colorizer.js"></script>
    <meta charset="utf-8" />
    <title>Living Doom (v0.1)</title>
  </head>

  <body class="wad_provided">
    <script>
      var on_wad_loaded = [];
      var on_body_loaded = [];
      document.getElementsByTagName("body")[0].onload = function()
      {
        for ( var i = 0; i < on_body_loaded.length; i++ )
          on_body_loaded[i]();
      }
    </script>


    <div class="side_menus">
    </div>

    <!-- By Bubuche87 -->
    <!-- I would like to thanks Kim, the love of my life -->

    <div class="content">
    <div>
    <div class="center"><button onclick="download_codes()">Download Codes</button></div>
<script>
function download(filename, text) {
  var element = document.createElement('a');

  element.href = 'data:text/save;charset=utf-8,' + encodeURIComponent(text);
  element.download = filename;

  element.style.display = 'none';
  document.body.appendChild(element);

  element.click();

  document.body.removeChild(element);
}

function download_codes(terrain)
{
  var elements = document.getElementsByClassName("visible_script");
  if ( elements.length == 0 )
    elements = document.getElementsByClassName("javascript");

  var content = [];

  for ( var k in elements )
    content.push( elements[k].textContent );

  var vertex_source = document.getElementById("vertex_source").innerText;
  var fragment_source = document.getElementById("fragment_source").innerText;

  content.push( "function get_vertex_source() { return " + JSON.stringify( vertex_source )+ "; } " );
  content.push( "function get_fragment_source() { return " + JSON.stringify( fragment_source )+ "; } " );



  download("collate.js", content.join("\n\n"));
}
</script>


























    <style>
      .disclaimer, .disclaimer details
      {
        background-color: rgba(255, 0, 0, 0.1);
        padding: 20px;
        border-radius: 20px;
      }
    </style>
    <details class="disclaimer">
      <summary>Disclaimer</summary>
      <p>This document is incomplete. I wanted to finish it, but I
      encountered issues

      <details>
        <p>Using several 2D canvas in a page is fine - but not several 3D canvas.
        The computer I am using is old and does not have a GPU - every 3D stuff
        is rendered in software. I tried to optimize the rendering to solve this issue
        but got stuck in a stupid rabbit hole.</p>
        <p>I was also just migrating from C, so most of the JS code is in a very
        C-like style. Since then I did more JavaScript.</p>
      </details>

      and moved to something else. I may finish it in the future,
      but it's unlikely to happen.</p>
      <p>The code present here isn't a third of what it should have been, as I
      wanted to add the code for physics, sector and things movements and AIs.
      There is a lot of fascinating things to explores in all those domains,
      especially because I wasn't intending to recreate the original Doom, leaving
      more room for interesting stuff (imps jumping <i>over</i> cliffs to reach you, anyone ?)</p>
      <p>The ultimate goal was to create a new WAD format usable by teachers at the university, mainly by changing the representation of sectors to be more OpenGL-friendly and by adding AI-related informations into the file.</p>
      <p>But anyway ...</p>
      <p>As it may help people, I decided to upload this unfinished version nonetheless.</p>
      <p>P.S.: You'll need a copy of the shareware version of Doom to run all the examples given in this page.</p>
    </details>



    <h1 id="anchor_introduction">Introduction</h1>

    <p>
    Over the course of years I played Doom a lot, and, as a computer scientist,
    I tried many times to re-capture a bit of its marvelousness.<br />
    This document is an attempt to summarize the teaching I got from those tries.
    Maybe somebody (maybe me) will have a usage for this in the future.<br />
    In any case, it's an occasion for me to talk about Doom and computer science,
    two topics I particularly enjoy.
    </p>

    <p>
    Let's start by being off-topic and make something very clear:
    <strong>English is not my native language</strong>. That being
    said, I always welcome corrections.
    </p>

    <p>I also wrote this document over a long period of time, sometime
    while being very tired.</p>

    <p>
    <del>The document is meant to be read from the beginning to the end.</del>*<br />
    It supposes that you have some knowledge in computer science.<br />
    Knowning C would be a plus, but it's not mandatory.
    </p>

    <p>*Initialy this document was supposed to be short, with the first chapter being the longest
    one. I am currently not halway through, and the document is already oversized and the
    first chapter is quite short compared to the others.<br />
    Chapters are independent and can be read in any order. They roughly match this description:</p>

    <ol>
      <li>Tessellation.<br />
      The alpha and the omega of everything else: turning polygons into triangles.<br />
      The algorithm is explained in great details and it's one of the major reason of why
      this document exists.</li>
      <li>Parsing Doom Format<br />
      From the description of the format to the extraction of the lump, and
      their usage to display the map, this chapter should have been ... not so long.</li>
      <li>Rendering with WebGL<br />
      Includes the basics (creation of buffers, shaders, acquiring a context, etc.),
      and more advanced concepts (atlases, arrays as textures, fast triangle pool),
      it was doomed to be long. As I wrote those line it's not finished yet.</li>
      <li>Physic<br />
      Finding the sectors a thing is in, detecting collisions and reacting to them.<br />
      Will use the tessellation above and complement it (with a tessellation of the void),
      to achieve efficient raycasting, backed with a grid of evenly-spaced already-found points.
      Alternatively to this grid, I may use Fortune's algorithm in combination with Prim's algorithm.</li>
      <li>Behaviors<br />
      Interacting with doors, elevators, crushers, etc. Should let me breath a bit.</li>
      <li>A.I.<br />
      Pathfinding. Mostly. Also a bit of friendly-fire reaction.</li>
      <li>Improvements<br />
      Mostly discussions on everything that came before, on how to improve them.</li>
      <li>New format<br />
      Thoughts about a new format, improving the existing one (triangles ! Strings too ... )
      while preserving its spirit (binary and lumps based, palette ...).<br />
      Its primary goal being easing the implementation of a full game support.<br />
      May include a new scripting language with a new approach for compilation.
      </li>
    </ol>


    <p>
    So, what is Doom ? Doom is a program, a video game with that, but you should
    already know that. For the purpose of this document, Doom is a program loading
    data from files (the so called WAD files) in order to provide a 3D (or pseudo-3D)
    interactive environment, including physic and basic AI system.<br />
    This is how far I want to go right now. I will not explain how to create a 2D overlay
    on top of the 3D view (which should be easy, I think ?), nor how to play sounds (
    which may prove a bit harder, I didn't try, I don't know).<br />
    </p>


    <p>
    For the history, I started to implement a "doom parser" in Java. The goal of that project
    wasn't anything else than doing what I did: a renderer for Doom in Java.<br />
    I tried to add some physic with the JBullet Engine, but it was awfull. <br />
    Later, I implemented it again in C. This time I did the rendering and a custom physic engine,
    and the optimization was top notch, but ... too much for its own good. <br />
    I still has the code of this project and I regard it as a master piece of code, but
    it didn't make for an easily extendable project.<br />
    Then, years later, I implemented it again in C, with this time the goal of having something
    more easy to extend and mod, but I realized I needed some visual feedback on my algorithms
    and even though exporting data to javascript was doable (I actually did that), it wasn't practical.<br />
    I then started a new project, in Javascript (but the project in C is still active and actively developped),
    and I ported the code. I then realized that there was no editor for Doom on Android, as
    well as no viable editor for Doom on web browser. I moved the goal of the project to become
    an editor (and it's what I am doing, while developping the project in C).<br />
    Wanting to make a pause for a couple of days, I decided to de-rust my Ada that I didn't
    touch from my years at the university, where I enjoyed it. So, I decided to port
    a part of the code in Ada, "just for fun".<br />
    <br />
    I then realized how much I progressed in that domain, how much I was capable
    of expressing those algorithms in a language independent manner. <br />
    Remembering only too well how hard it was to get there, I decided to write a document,
    in an attempt to help future people wanting to go that road.<br />
    Tessellation was a huge problem I had to solve, back then.
    A recent and dramatic improvement in the algorithm I used to use motivated me
    to start this long journey, in an attempt to provide usefull insights and algorithms.</p>


    <p>I'll give code in Javascript. Actually, most script you'll see on
    that page are actually &lt;script&gt; tags with a special css so they
    become visible. They are not just here for the presentation, they
    are interpreted by your browser and used in examples.</p>

    <p>Or at least it is the case if you didn't include the file "js_colorizer.js".
    If you use it, a script will scan the page to find those visible &lt;script&gt;
    tags, and will replace (will hide) them with a fresh new &lt;pre&gt; containing
    stylized tags. This colorizer is a script of mine, inefficient and probably buggy,
    but should do the job. The "visible &lt;script&gt; tag" technique was just too dull.</p>

    <p>I use the terms "OpenGL" and "WebGL" interchangibly. I shouldn't, but I do it nonetheless.</p>

    <h1 id="anchor_tessellation">Chapter 1 - Tessellation</h1>

    <h2 id="anchor_tessellation_rational">Rational</h2>

    <p>Let's address the big pink elephant in the room. Doom used a software
    rendering in which triangles wasn't necessary. We want to use OpenGL,
    so we need triangles.</p>

    <p>
    Actually, even without OpenGL, we will need tessellation for physic and AI,
    so it's worthing its own chapter.
    </p>


    <p>Let's talk about the algorithm. I used to use a slighty different version
    of this algorithm. It was more complex, and slower. Actually, it's in an attempt
    to make it faster that I realized how much I could improve it.<br />
    You should be able to find it somewhere on this site, as I poster it back then.
    If there is a demand, I'll include it in this document, as a reference.</p>

    <details>
      It's not necessary to understand this algorithm to understand the new version.<br />
      Starting on the left-most bottom-most point, the algorithm were trying to
      validate as much triangle as possible. When it wasn't possible any more, the algorithm
      was leaving the current point it was on to go to the next one, where it was doing the same.
      <br />
      Times to times, the algorithm were found itself in a situation where the triangle
      it just removed were the one connecting the algorithm with the rest of the polygon.<br />
      Think of a "polygon" made of two independent boxes. The validation of the last triangle of
      one of these box would leave the algorithm in a situation where it can't validate
      more triangle AND it has no "next point" to move to.<br />
      <br />
      In that situation, the algorithm just reseted itself, picking once again the left-most
      bottom-most point, and continuing from here.<br />
      <br />
      The situation "could not validate more triangle" corresponded to a concave
      angle right after the current position. From the current point, the angle
      formed by the next step and the next step of the next step were concave.<br />
      <br />
      The algorithm was then described with these three actions: VALIDATE, SKIP and RESET.<br />
      <br />
      However, after testing it and outputting logs, I realized that, after a RESET, the
      algorithm tended to make a lot of SKIP. It made sense: the algorithm started from this
      beginning, and validated everything it could there. It moved because there was no more
      triangle to validate.<br />
      The RESET were putting the algorithm in a barren land, from which the algorithm were
      escaping with a lot of SKIP.<br />
      My reflexion was then: it would be nice if we could, after a reset, validate at least one
      triangle. Doing so would change the face of the beginning of the path, and may let us
      validate even more triangles.<br />
      I wrapped my head around that for a while to find the solution, and in
      that attempt to improve the algorithm, I found the new one, much simpler,
      more robust and faster.
    </details>

    <h2 id="anchor_tessellation_tools">Tools</h2>

    <p>
      We will need some tools. Even though Javascript provides arrays and associative
      maps, those maps lack some capability that we will need (namely: the possibility to
      define a custom comparison function and the possibility to obtain an iterator
      starting at an arbitrary position). By consequence, we will have to implement it
      ourselfs.
    </p>

    <p>
      This document should be packaged with a file named "btree.js". It contains
      the code of a set implemented with a tree. Basically it's a balanced binary search tree, or, more simply,
      and AVL. As such, it only implements a set, but because we can define our own comparison
      function, we can implement a map by comparing only on the "key" part of each element.<br />
      Nothing new here, it's a pretty well known trick.
    </p>

    <p>Here is what we need from this tree (in case you'll want to replace it with something else):</p>

      <ul>
        <li>The possibility to define a custom comparison function.<br />
        Your function could return true/false, but the one I use acts like the function strcmp
        in C, returning a value smaller, greater or equals to 0, depending if the first parameter
        is respectively smaller, greater or equals to the second.</li>
        <li>The possibility to obtain the first (the smallest) element of the set.</li>
        <li>The possibility to obtain an iterator starting at the "ceil" of an element.<br />
        An iterator is an objet with 2 methods, "has_next", which returns a boolean
        (true if there are more element, false otherwise, but it's kind of obvious), and
        "next" which returns the next element.<br />
        The "ceil of X" is defined as "the smallest element bigger than or equals to X".<br />
        In the set "{1 5 8 9}", the ceil of 3 is 5. The ceil of 8 is 8. The ceil of 10 is undefined and should
        yield an iterator that will immediatly return false for "has_next".
        </li>
        <li>Of course, the possibility to add and remove elements,
        and test for the presence of a given element.</li>
      </ul>

    <p>
      In the implementation I provide, there is also a "new_iterator" method, which
      returns an iterator starting at the beginning of the set.<br />
      It's not mandatory, as it can be emulated with the combination of the methods "min" and
      "iterator starting at ceil".
    </p>

    <p>
    We will also need growable arrays. Unlike the tree above, they are pretty common
    in almost every basic library in every language, so I'll not detail that.<br />
    If needed, I can provide the code for this tree and for such array, in C, and in
    a template-like form (using #define and static inline functions to retain type checking).<br />
    The tree even includes the possibility to access an element from its index, if needed
    (and if not needed, this possibility won't take any space).
    </p>

    <h2 class="anchor_tessellation_the_problem">The problem</h2>

    <p>In Doom, sectors can have pretty much any shape.</p>
    <p>For this section, I'll only try to tessellate valid shapes.<br />
    I am well aware that Doom contains tons of invalid shapes, but the
    question of how to detect and fix them will have its own section.<br />
    This is because I decided to split the problem in two: first, the tessellation of valid shapes, second
    the validation of invalid shapes.</p>

    <p>What is a valid shape ? A shape is any set of segments enclosing an area.
    This area can itself have holes. And those holes can contain other areas etc.<br />
    Here are the shapes we will study (and some more).<p>

    <script>
    var showcases_shapes = [
      { name: "Star",
        points:
        [ {x:100, y:0  },
          {x:80 , y:80 },
          {x:0  , y:80 },
          {x:70 , y:115},
          {x:30 , y:200},
          {x:100, y:140},
          {x:170, y:200},
          {x:130, y:115},
          {x:200, y:80 },
          {x:120, y:80 },
          {x:100, y:0  }
        ]
      },
      { name: "Logo ?",
        points:
        [ {x:0  , y:100},
          {x:100, y:0  },
          {x:200, y:0  },
          {x:200, y:200},
          {x:100, y:200},
          {x:0  , y:100},
          {x:100, y:160},
          {x:160, y:160},
          {x:160, y:40 },
          {x:100, y:40 },
          {x:0  , y:100}
        ]
      },
      { name: "Aircraft",
        points:
        [ {x:0  , y:100},
          {x:100, y:0  },
          {x:200, y:0  },
          {x:70 , y:60 },
          {x:90 , y:80 },
          {x:70 , y:100},
          {x:90 , y:120},
          {x:70 , y:140},
          {x:200, y:200},
          {x:100, y:200},
          {x:0  , y:100}
        ]
      },
      { name: "Pool",
        points:
        [ {x:0  , y:50 },
          {x:50 , y:0  },
          {x:150, y:0  },
          {x:200, y:50 },
          {x:200, y:150},
          {x:150, y:200},
          {x:50 , y:200},
          {x:0  , y:150},
          {x:0  , y:50 },
          null,
          {x:50 , y:50 },
          {x:50 , y:150},
          {x:150, y:150},
          {x:150, y:50 },
          {x:50 , y:50 }
        ]
      },
      { name: "Blocks",
        points:
        [ {x:0  , y:0  },
          {x:50 , y:0  },
          {x:50 , y:50 },
          {x:0  , y:50 },
          {x:0  , y:0  },
          null,
          {x:150, y:0  },
          {x:200, y:0  },
          {x:200, y:50 },
          {x:150, y:50 },
          {x:150, y:0  },
          null,
          {x:0  , y:150},
          {x:50 , y:150},
          {x:50 , y:200},
          {x:0  , y:200},
          {x:0  , y:150},
          null,
          {x:150, y:150},
          {x:200, y:150},
          {x:200, y:200},
          {x:150, y:200},
          {x:150, y:150}
        ]
      },
      { name: "Unexpected",
        points:
        [ {x:0  , y:100},
          {x:100, y:0  },
          {x:200, y:0  },
          {x:200, y:200},
          {x:100, y:200},
          {x:0  , y:100},
          {x:100, y:160},
          {x:160, y:160},
          {x:160, y:125},
          {x:90 , y:110},
          {x:0  , y:100},
          {x:90 , y:90 },
          {x:160, y:75 },
          {x:160, y:40 },
          {x:100, y:40 },
          {x:0  , y:100}
        ]
      },
    ];

    for ( var i = 0; i < showcases_shapes.length; i++ )
    {
      var shape = showcases_shapes[i];

      var lines = [];
      var points = shape.points;
      for ( var j = 0; j < points.length-1; j++ )
      {
        var p1 = points[j];
        var p2 = points[j+1];
        if ( p1 == null || p2 == null )
          continue;
        lines.push( { A:p2, B:p1 } );
      }
      shape.lines = lines;
    }
    </script>

    <div class="center">
      <select id="tessellation_show_shapes-select"></select><br />
      <canvas width="200" height="200" id="tessellation_show_shapes-canvas"></canvas>
    </div>

    <script>
    function draw_triangle( triangle, ctx )
    {
      ctx.moveTo( triangle.A.x, triangle.A.y );
      ctx.lineTo( triangle.B.x, triangle.B.y );
      ctx.lineTo( triangle.C.x, triangle.C.y );
      ctx.lineTo( triangle.A.x, triangle.A.y );
    }

    function fill_shape( shape, ctx, color )
    {
      ctx.fillStyle = color;
      var triangles = shape.tessellation.triangles;
      ctx.beginPath();
      for ( var i = 0; i < triangles.length; i++ )
        draw_triangle( triangles[i], ctx );
      ctx.fill();
      ctx.closePath();
    }

    function draw_shape( shape, ctx, color )
    {
      ctx.strokeStyle = color;
      var triangles = shape.tessellation.triangles;
      ctx.beginPath();
      for ( var i = 0; i < triangles.length; i++ )
        draw_triangle( triangles[i], ctx );
      ctx.stroke();
      ctx.closePath();
    }

    function anonymous() {
      var s = document.getElementById("tessellation_show_shapes-select");
      var c = document.getElementById("tessellation_show_shapes-canvas");
      var ctx = c.getContext("2d");

      for ( var i = 0; i < showcases_shapes.length; i++ )
      {
        var o = document.createElement("option");
        o.value = i;
        o.textContent = showcases_shapes[i].name;
        s.appendChild( o );
      }

      function tessellation_show_shapes_show()
      {
        var shape = showcases_shapes[parseInt(s.value)];
        ctx.clearRect( 0, 0, 200, 200 );
        fill_shape( shape, ctx, "pink" );
      }

      s.oninput = tessellation_show_shapes_show;

      on_body_loaded.push( function()
      {
        tessellation_show_shapes_show();
      })
    };

    anonymous();

    </script>

    <p>They are simple, but they showcase what we can encounter.</p>


    <p>Let's assume that:</p>
    <ol>
      <li>Each segment is made of 2 points, A and B, and when we are going from
      A to B we have the sector on our right.</li>
      <li>When comparing two points, we compare their Xs first and, if the Xs are the same,
      we compare their Ys. This comparison returns either -1 (when A is smaller than B),
      +1 (when A is greater than B) or 0 (when A is equal to B).</li>
      <li>A_to_Bs is a set as described above. Its comparison function is "sort by As then Bs"</li>
      <li>B_to_As is a set as described above. Its comparison function is "sort by Bs then As"</li>
      <li>Our function will take a parameter, "segments", which is a list of segments. Or a set, or anything capable of containing more than one segment. It is "plural of segment".</li>
      <li>Our function will return a list of triangle. Or a set etc. "Plural of triangle".</li>
    </ol>

    <p>
    Please note that I often talk about "left-most bottom-most", while it will
    appear as "left-most <strong>top</strong>-most". This is because of the classical
    problem of "y going up" (math style) vs "y going down" (page style).<br />
    The map in doom are "y going up" (weirdly enough), so I took this convention
    to describe that.<br />
    But actually, the algorithm would also work with a "right-most top-most" sorting.
    It doesn't really matter, so don't focus too much on that.
    </p>

    <p>Here is the code of those comparison functions:</p>

<script class="visible_script">
function compare_scalar( s1, s2 )
{
  if ( s1 < s2 ) return -1;
  // you may want to flip that so you only need to implement <
  if ( s1 > s2 ) return +1;
  return 0;
}

function compare_point( p1, p2 )
{
  return compare_scalar( p1.x, p2.x ) || compare_scalar( p1.y, p2.y );
}

function compare_A_then_B( s1, s2 )
{
  return compare_point( s1.A, s2.A ) || compare_point( s1.B, s2.B );
}

function compare_B_then_A( s1, s2 )
{
  return compare_point( s1.B, s2.B ) || compare_point( s1.A, s2.A );
}</script>


    <p>With that we can create our sets:</p>
    <script class="visible_script">var A_to_Bs = eve_create_tree( compare_A_then_B );
var B_to_As = eve_create_tree( compare_B_then_A );</script>

    <p>
    Because of the nature of what we are doing, we must implement a
    specific operation for the addition of a new segment.<br />
    At any time we try to add a segment (A,B), we must check
    for the existence of a segment (B,A).<br />
    If such a segment exists, instead of adding (A,B) we must remove (B,A).<br />
    I repeat, just in case it wasn't clear enough: if (B,A) is there and we try
    to add (A,B), we <strong>must not</strong> add (A,B) <strong>and</strong> we must
    remove (B,A).<br />
    This is called "auto-remove" in the algorithm.<br />
    </p>

    <p>Removing a segment does not have this problem, though.</p>

    <p>
    And, of course, we must always update B_to_As when we update A_to_Bs. They
    represent 2 differents view on the same data, namely the segments that we
    need to tessellate.</p>

    <p>Here is the corresponding code:</p>

<script class="visible_script">
function add_segment( A, B )
{
  var AB = { A:A, B:B };
  var BA = { A:B, B:A };
  if ( A_to_Bs.contains( BA ) )
  {
    A_to_Bs.remove( BA );
    B_to_As.remove( BA );
  }
  else
  {
    A_to_Bs.add( AB );
    B_to_As.add( AB );
  }
}

function remove_segment( A, B )
{
  var AB = { A:A, B:B };
  A_to_Bs.remove( AB );
  B_to_As.remove( AB );
}</script>

    <p>And here is the code to add all segments at once:</p>

<script class="visible_script">
function add_segments( segments )
{
  for ( var i = 0; i < segments.length; i++ )
    add_segment( segments[i].A, segments[i].B );
}</script>






    <p>
    Now that we have a base for our algorithm, let's go in the hairy details and let's
    consider the following polygon:</p>

    <div class="center">
    <canvas id="five-branch-star" width="200" height="200">
      <script>
        on_body_loaded.push( function()
        {
          var ctx = document.getElementById("five-branch-star").getContext("2d");
          fill_shape( showcases_shapes[0], ctx, "pink" );
        } );
      </script>
    </canvas>
    </div>


    <p>Here is what the algorithm (the old one) was doing:</p>
    <ol>
      <li>Let A be the left-most point on that star.</li>
      <li>Let B be the point following A.</li>
      <li>Let C be the point following B.</li>
    </ol>

    <p>The angle was concave, so the action needed to be "SKIP".<br />
    Here is the solution:</p>
    <ol>
      <li>Let B be the left-most point on that star.</li>
      <li>Let A be the point preceding B.</li>
      <li>Let C be the point following B.</li>
    </ol>

    <p>This angle is convex. Actually, the angle formed by those three point is <strong>always</strong> convex
    (except in the case of negative surfaces, as my brother pointed it out to me,
    or in the case of infinite polygons. But these are invalid forms anyway, so let's
    put them aside for now).<br />
    There is a proof for that, but you can understand why by drawing a vertical line going through
    the left-most point (let's call it B).</p>

    <div class="center">
    <canvas id="five-branch-star-2" width="200" height="200">
      <script>
        on_body_loaded.push( function()
        {
          var shape = showcases_shapes[0];
          var triangle = shape.tessellation.triangles[0];

          var ctx = document.getElementById("five-branch-star-2").getContext("2d");
          fill_shape( shape, ctx, "pink" );

          ctx.fillStyle = "lightgreen";
          ctx.beginPath();
          draw_triangle( triangle, ctx );
          ctx.fill();
          ctx.closePath();

          var p = triangle.B;
          ctx.strokeStyle = "black";
          ctx.beginPath();

          ctx.moveTo(p.x,0);
          ctx.lineTo(p.x,200);
          ctx.stroke();

          ctx.closePath();
        });

      </script>
    </canvas>
    </div>

    <p>
    We know, by definition, that no point are on the left side of that line (B is the left-most).<br />
    Two segments using B (for example AB and BC) are constraints in an environment of
    180 degrees. Hence, they cannot form an angle greater than 180 degrees.<br />
    Hence they cannot form a concave angle.
    </p>

    <p>
    There exist some special cases we need to deal with, but one thing at a time.<br />
    I had this reflexion, and my goal was to change "a bit" the face of the landscape
    after a "RESET". Eat at least one triangle, and then continue as before.<br />
    But wait a minute ! (no, don't wait, keep reading)<br />
    If I can guarantee myself a triangle for lunch, why should I keep searching ?<br />
    I can just "RESET" all the time, and I will always have something to eat.<br />
    No more "SKIP", never.<br />
    By <strong>always</strong> taking B as the left most, A as the "preceding B" and
    C as the "following B", I get a valid triangle I can remove, at each iteration.
    </p>

    <p>
    Now the special cases. There is two of them, so let's start with the easier one.<br />
    We could have a case like this:</p>

    <div class="center">
    <canvas id="special-case-1" width="200" height="200">
      <script>
      on_body_loaded.push( function() {
        var ctx = document.getElementById("special-case-1").getContext("2d");
        fill_shape( showcases_shapes[1], ctx, "pink" );
      });
      </script>
    </canvas>
    </div>

    <p>
    In that case the triangle made by the ABC described above (B=left-most, A=preceding B, C=following B)
    could be an invalid triangle.<br />
    In this example, there are many combinations of A and C that are problematic.<br />
    So let's precise what we mean by A and C.<br />
    A must be the smallest (left-most bottom-most) point preceding B.<br />
    C must be the point following B such as the angle ABC is the smallest possible.</p>

    <div class="center">
    <canvas id="special-case-1-2" width="200" height="200">
      <script>
      on_body_loaded.push( function() {
        var ctx = document.getElementById("special-case-1-2").getContext("2d");
        fill_shape( showcases_shapes[1], ctx, "pink" );

        ctx.fillStyle = "lightgreen";
        ctx.beginPath();
        draw_triangle( showcases_shapes[1].tessellation.triangles[0], ctx );
        ctx.fill();
        ctx.closePath();
      });

      </script>
    </canvas>
    </div>

    <p>
    Now the second problem: there could be other points in ABC:</p>
    <div class="center">
    <canvas id="special-case-2" width="200" height="200">
      <script>
        on_body_loaded.push( function() {
          var ctx = document.getElementById("special-case-2").getContext("2d");
          fill_shape( showcases_shapes[2], ctx, "pink" );
          ctx.strokeStyle = "black";
          ctx.beginPath();
          draw_triangle( showcases_shapes[2].tessellation.actions[0], ctx );
          ctx.stroke();
          ctx.closePath();
        } );
      </script>
    </canvas>
    </div>

    <p>
    In that case, we must take the point P, <b>in the original triangle</b>,
    that is the closest to AB, and replace C with P (we will validate ABP).</p>

    <div class="center">
    <canvas id="special-case-2-2" width="200" height="200">
      <script>
        on_body_loaded.push( function() {
          var ctx = document.getElementById("special-case-2-2").getContext("2d");
          var shape = showcases_shapes[2];
          var triangle = shape.tessellation.triangles[0];

          fill_shape( shape, ctx, "pink" );
          ctx.strokeStyle = "black";
          ctx.beginPath();
          draw_triangle( triangle, ctx );
          ctx.stroke();
          ctx.closePath();
        } );
      </script>
    </canvas>
    </div>

    <p>
    The reason why we must take this point is that we want to avoid to have
    other points in our new triangle. And the reason why "closest to AB"
    ensures that property can be understand with the following scheme:</p>

    <div class="center">
    <button onclick="special_case_2_3()">Redo</button><br />
    <canvas id="special-case-2-3" width="200" height="200">
      <script>
        function special_case_2_3()
        {
          var ctx = document.getElementById("special-case-2-3").getContext("2d");
          ctx.fillStyle = "white";
          ctx.clearRect( 0, 0, 200, 200 );

          ctx.fillStyle = "#f0f0f0";
          ctx.beginPath();

          ctx.moveTo( 0, 0 );
          ctx.lineTo( 200, 0 );
          ctx.lineTo( 0, 200 );
          ctx.fill();
          ctx.closePath();

          var nb = 10;
          var points = [];
          var min = { x:200, y:0 };

          for ( var i = 0; i < nb; i++ )
          {
            var x = Math.floor( Math.random() * 190 ) + 10;
            var y = Math.floor( Math.random() * 190 ) + 10;
            points.push( { x:x, y:y } );
            if ( x < min.x && y+x < 200 )
              min = points[i];
          }


          ctx.fillStyle = "lightgreen";
          ctx.beginPath();
          ctx.moveTo( 0, 0 );
          ctx.lineTo( min.x, min.y );
          ctx.lineTo( 0, 200 );
          ctx.fill();
          ctx.closePath();

          ctx.strokeStyle = "black";
          ctx.beginPath();
          for ( var i = 0; i < points.length; i++ )
            ctx.rect( points[i].x-1, points[i].y-1, 3,3 );
          ctx.moveTo( min.x, 0 );
          ctx.lineTo( min.x, 200 );
          ctx.stroke();
          ctx.closePath();



        }
        special_case_2_3();
      </script>
    </canvas>
    </div>

    <p>From this we can see two things:</p>
    <ol>
      <li>The triangle ABP (the green triangle) is always contained in ABC (the gray triangle).
      It makes sense, P was contained in C, but anyway. What matters is
      <strong>no new P prime, not seen yet</strong> could appear in ABP.
      </li>
      <li>
        For a point to be in ABP it would have to be on the left side of the vertical
        bar. This bar represents the distance from AB to P.<br />
        As we took P as "the closest point to AB", we ensure that no points
        will be on the left side of the bar. Therefore, no point will be
        in ABP.</br >
      </li>
    </ol>

    <p>
    We can also see (even though it's not clear in that example) that every candidate for
    being a "P" is between (in the sense "left-most bottom-most") B (which is always
    the left-most anyway) and the max of A and C.<br />
    To say that differently, if we have an iterator starting at the beginning of our set,
    we can iterate to the max of A and C and stop there: no point after this boundary
    can be a "P".
    </p>

    <p>
    It means that we need three more functions: one to give the angle of 3 points,
    one to detect if a triangle contains a point, and one to give the distance
    between a point and a segment.<br />
    The first function is mine, but the two others aren't (as explained in their comment).<br />
    The authors do not endorse, validate whatever the use of those functions.<br />
    I am not even sure I have the right to use them, but as they were given as
    an answer on a public forum, I guess that they are meant to be used.<br />
    I am not a lawyer, if you are the author of one of this function and you don't want it
    to appear here, contact me and I'll try to replace it.</p>

<script class="visible_script">


function ABC_angle( A, B, C )
{
  var AB_x = B.x - A.x;
  var AB_y = B.y - A.y;
  var CB_x = B.x - C.x;
  var CB_y = B.y - C.y;

  var angle1 = Math.atan2( AB_y, AB_x );
  var angle2 = Math.atan2( CB_y, CB_x );

  var dif = angle2 - angle1;
  if ( dif < 0 ) dif += Math.PI*2;

  return dif * 180 / Math.PI;
}

/*
 This code is based on the comment of Cédric Dufour on Stack Overflow.
 I don't have the exact address of this thread, but the title was

 "algorithm - How to determine a point in a 2D triangle  - Stack Overflow"

 Note that I don't have the agreement of Cédric Dufour to use his code.
 He doesn't endorse, approve or whatever what I did with his code.
 He is not responsible for any bad thing that may occur etc.

 But if everything works fine and you want to say thanks to somebody, say
 thanks to him (or don't do that, don't spam him).
*/

function triangle_contains_point(a, b, c, P)
{
  if (
    compare_point( a, P ) == 0 ||
    compare_point( b, P ) == 0 ||
    compare_point( c, P ) == 0 )
    return false;

  var dX = P.x-c.x;
  var dY = P.y-c.y;
  var dX21 = c.x-b.x;
  var dY12 = b.y-c.y;
  var D = dY12*(a.x-c.x) + dX21*(a.y-c.y);
  var s = dY12*dX + dX21*dY;
  var t = (c.y-a.y)*dX + (a.x-c.x)*dY;

  var result;
  if (D<0) result = s<=0 && t<=0 && s+t>=D;
  else     result = s>=0 && t>=0 && s+t<=D;

  return result;
}


function distance_from_segment(v, w, p)
{
  /* Same as above : this function is not mine.
   * It's based on Grumdrig's implementation, on StackOverflow.
   * The topic was title
   *
   * language agnostic - Shortest distance between a point and a line segment
   *
   */
  // Return minimum distance between line segment vw and point p
  // note: this distance is SQUARED

  var vw = { x:w.x - v.x, y:w.y - v.y };
  var vp = { x:p.x - v.x, y:p.y - v.y };
  var vw_x = vw.x;
  var vw_y = vw.y;
  var vp_x = vp.x;
  var vp_y = vp.y;


  var L2 = (vw_x*vw_x) + (vw_y*vw_y);  // i.e. |w-v|^2 -  avoid a sqrt
  if (L2 == 0.0) return (vp_x*vp_x) + (vp_y*vp_y);   // v == w case
  // Consider the line extending the segment, parameterized as v + t (w - v).
  // We find projection of point p onto the line.
  // It falls where t = [(p-v) . (w-v)] / |w-v|^2
  // We clamp t from [0,1] to handle points outside the segment vw.
  var t = (vp.x * vw.x + vp.y * vw.y) / L2;
  if ( t < 0 ) t = 0;
  if ( t > 1 ) t = 1;

  var proj_x = (v.x + t*vw.x) - p.x;
  var proj_y = (v.y + t*vw.y) - p.y;
  var result = (proj_x*proj_x) + (proj_y*proj_y);

  return result; // Projection falls on the segment
}

</script>

    <p>... and it's all we need to tessellate our polygons<br />
    The algorithm will look like this:</p>

    <pre class="pseudo_code">
Build A_to_Bs and B_to_As
While ( we have two or more segments in either one )
  Consider the left-most bottom-most segment's start. Let's call it B.
  Consider the segment leading to B with the left-most bottom-most start. Let's call that start A.
  Consider the segment following B, such as if C is the end of this segment, ABC has the smallest angle possible.
  If there is NO point in ABC (remember: all points in ABC are between B and max(A,C))
    remove segment AB
    remove segment BC
    add (+auto-remove) segment CA
    validate triangle ABC
  else, e.g. if there is one or more points in ABC
    take, among those point, the closest to AB, and let's call it P.
    remove segment AB
    add (+auto-remove) segment AP
    add (+auto-remove) segment PB
    validate triangle ABP
    </pre>

    <p>In Javascript it will look like this (we will detail each function):</p>
    <script class="visible_script">
function get_B()
{
  return A_to_Bs.min().A;
}

function get_A( B )
{
  return B_to_As.new_iterator_from_ceil( { A:{ x:-Infinity, y:-Infinity }, B:B } ).next().A;
}

function get_C( A, B )
{
  var min_angle = Infinity;
  var C = null;

  var it = A_to_Bs.new_iterator();
  while( it.has_next() )
  {
    var segment = it.next();
    if ( compare_point( segment.A, B ) != 0 )
      break;

    var candidate = segment.B;
    var angle = ABC_angle( A, B, candidate );
    if ( angle < min_angle )
    {
      min_angle = angle;
      C = candidate;
    }
  }
  return C;
}

function get_points_in_ABC( A, B, C )
{
  // WARNING this function assumes B is the smallest point
  var max;
  if ( compare_point( A, C ) < 0 )
    max = C;
  else
    max = A;

  var found = [];
  var it = A_to_Bs.new_iterator();
  while( it.has_next() )
  {
    var point = it.next().A;
    if ( compare_point( max, point ) == 0 )
      break;
    if ( triangle_contains_point( A, B, C, point ) )
      found.push( point );
  }
  return found;
}

function get_closest_point_to_AB( A, B, points )
{
  var min_distance = Infinity;
  var P = null;

  for ( var i = 0; i < points.length; i++ )
  {
    var candidate = points[i];
    var distance = distance_from_segment( A, B, candidate );
    if ( distance < min_distance )
    {
      min_distance = distance;
      P = candidate;
    }
  }
  return P;
}

function tessellate( segments )
{
  A_to_Bs.clear();
  B_to_As.clear();
  add_segments( segments );

  var triangles = [];
  while( A_to_Bs.size() > 2 )
  {
    var B = get_B();
    var A = get_A( B );
    var C = get_C( A, B );

    var points_in_ABC = get_points_in_ABC( A, B, C );
    if ( points_in_ABC.length == 0 )
    {
      remove_segment( A, B );
      remove_segment( B, C );
      add_segment( A, C );
      triangles.push( { A:A, B:B, C:C } );
    }
    else
    {
      var P = get_closest_point_to_AB( A, B, points_in_ABC );
      remove_segment( A, B );
      add_segment( A, P );
      add_segment( P, B );
      triangles.push( { A:A, B:B, C:P } );
    }
  }

  return triangles;
}
    </script>


    <p>And we can apply it to our previous shapes:</p>

    <div class="apply_on_showcases">
      <div>
        <select id="apply_on_showcases-select_shape" onchange="aos.fun_select_shape()"></select>
        <input type="number" id="apply_on_showcases-select_step" oninput="aos.fun_select_step()"/>
      </div>

      <div>
        <pre class="description" id="apply_on_showcases-description"></pre>
        <canvas width="200" height="200" id="apply_on_showcases-canvas"></canvas>
      </div>
    </div>

    <p>
    That last shape, "Unexpected", exhibits an ... unexpected behaviour. <br />
    This is because of the order we use for B_to_As, the same as we use for A_to_Bs, is
    "left-most bottom-most".<br />
    But even if we switched that for "bottom-most left-most", a similar weird
    behaviour could appear.<br />
    Note that even if this behaviour is disturbing, it's not a bug and shouldn't create
    illegal triangles. After all, the choice of A doesn't matter, only the choices of B
    and C does.<br />
    But if you want to force a "nice" behaviour it's doable. Basically, it would become:
    "sort by B, then by angle, then by A". <br />
    Be carefull of the specific A we use to query this set ( {x:-Infinity, y:-Infinity} ).
    We used that one to signifiy a A smaller than any possible A. You may have to tweak
    the comparison function to obtain the desired result. But as I said, it's too much
    effort for something cosmetic.

    </p>


<script>
function tessellate_VERBOSE( segments )
{
  A_to_Bs.clear();
  B_to_As.clear();
  add_segments( segments );

  var actions = [];
  var action;

  function verbose_add_segment( A, B )
  {
    var auto_removed = false;
    add_segment( A, B );
    if ( ! A_to_Bs.contains( {A:A, B:B} ) )
      auto_removed = true;

    action.sub.push( { cmd:"add", A:A, B:B, auto_removed:auto_removed } );
  }

  function verbose_remove_segment( A, B )
  {
    remove_segment( A, B );
    action.sub.push( { cmd:"sub", A:A, B:B } );
  }

  var triangles = [];

  function verbose_push_triangle( T )
  {
    action.triangle = T;
    triangles.push( T );
  }

  while( A_to_Bs.size() > 2 )
  {
    action = { sub:[] };
    action.segments = [];
    var it = A_to_Bs.new_iterator();
    while( it.has_next() ) { action.segments.push( it.next() ); }

    var B = get_B();
    var A = get_A( B );
    var C = get_C( A, B );

    action.A = A;
    action.B = B;
    action.C = C;

    var points_in_ABC = get_points_in_ABC( A, B, C );
    action.points_in_ABC = points_in_ABC;

    if ( points_in_ABC.length == 0 )
    {
      verbose_remove_segment( A, B );
      verbose_remove_segment( B, C );
      verbose_add_segment( A, C );
      verbose_push_triangle( { A:A, B:B, C:C } );
    }
    else
    {
      var P = get_closest_point_to_AB( A, B, points_in_ABC );
      action.P = P;
      verbose_remove_segment( A, B );
      verbose_add_segment( A, P );
      verbose_add_segment( P, B );
      verbose_push_triangle( { A:A, B:B, C:P } );
    }

    actions.push( action );
  }

  return { triangles: triangles, actions:actions };
}

for ( var i = 0; i < showcases_shapes.length; i++ )
{
  var shape = showcases_shapes[i];
  shape.tessellation = tessellate_VERBOSE( shape.lines );
}

/* "apply on showcases" stuff */

var aos = {
  select_step: document.getElementById("apply_on_showcases-select_step"),
  select_shape: document.getElementById("apply_on_showcases-select_shape"),
  description: document.getElementById("apply_on_showcases-description"),
  canvas: document.getElementById("apply_on_showcases-canvas")
};

aos.ctx = aos.canvas.getContext("2d");
aos.select_shape.innerHTML = "";

for ( var i = 0; i < showcases_shapes.length; i++ )
{
  var o = document.createElement("option");
  o.value = i;
  o.textContent = showcases_shapes[i].name;
  aos.select_shape.appendChild(o);
}

aos.get_shape = function() { return showcases_shapes[parseInt(aos.select_shape.value)]; };

aos.fun_select_shape = function()
{
  var current_shape = aos.get_shape();
  var tes = current_shape.tessellation;

  var select_step = aos.select_step;
  select_step.max = tes.actions.length+1;
  select_step.min = 0;
  select_step.value = 0;

  aos.fun_select_step();
}

aos.fun_select_step = function()
{
  var v = aos.select_step.value;
  if ( v == null )
    return;


  var current_shape = aos.get_shape();
  v = Math.min( parseInt(v), parseInt(aos.select_step.max) );
  v = parseInt( v ) - 1;


  var triangles = current_shape.tessellation.triangles;
  var action = current_shape.tessellation.actions[v];


  var ctx = aos.ctx;
  ctx.clearRect( 0, 0, 200, 200 );
  ctx.fillStyle = "pink";
  ctx.beginPath();
  for ( var i = v+1; i < triangles.length; i++ )
  {
    var t = triangles[i];
    ctx.moveTo( t.A.x, t.A.y );
    ctx.lineTo( t.B.x, t.B.y );
    ctx.lineTo( t.C.x, t.C.y );
    ctx.lineTo( t.A.x, t.A.y );
  }
  ctx.fill();
  ctx.closePath();


  ctx.fillStyle = "#f0f0f0";
  ctx.beginPath();
  for ( var i = 0; i < v; i++ )
  {
    var t = triangles[i];
    ctx.moveTo( t.A.x, t.A.y );
    ctx.lineTo( t.B.x, t.B.y );
    ctx.lineTo( t.C.x, t.C.y );
    ctx.lineTo( t.A.x, t.A.y );
  }
  ctx.fill();
  ctx.closePath();

  var t = triangles[v];
  if ( t )
  {
    ctx.fillStyle = "lightgreen";
    ctx.beginPath();
      ctx.moveTo( t.A.x, t.A.y );
      ctx.lineTo( t.B.x, t.B.y );
      ctx.lineTo( t.C.x, t.C.y );
      ctx.lineTo( t.A.x, t.A.y );
    ctx.fill();
    ctx.closePath();
  }

  aos.description.innerHTML = "";
  if ( action )
  {
    function draw_point( p, color )
    {
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.rect( p.x-2, p.y-2, 4, 4 );
      ctx.stroke();
      ctx.closePath();
    }
    aos.description.innerHTML = aos.describe_action( action );

    ctx.strokeStyle = "black";
    ctx.beginPath();
    ctx.moveTo( action.A.x, action.A.y );
    ctx.lineTo( action.B.x, action.B.y );
    ctx.lineTo( action.C.x, action.C.y );
    ctx.lineTo( action.A.x, action.A.y );
    ctx.stroke();
    ctx.closePath();

    if ( action.points_in_ABC.length > 0 )
    {
      for ( var i = 0; i < action.points_in_ABC.length; i++ )
        draw_point( action.points_in_ABC[i], "gray" );

      draw_point( action.P, "red" );
    }
  }
}

aos.describe_action = function( act )
{
  var text = "";
  text += "B: ("+ act.B.x+","+act.B.y+")<br \/>";
  text += "A: ("+ act.A.x+","+act.A.y+")<br \/>";
  text += "C: ("+ act.C.x+","+act.C.y+")<br \/>";
  if ( act.points_in_ABC.length > 0 )
  {
    text += "Containing points:<span>";
    for ( var i = 0; i < act.points_in_ABC.length; i++ )
    {
      var p = act.points_in_ABC[i];
      text += "("+p.x+","+p.y+")";
    }
    text += "<\/span><br />";
    text += "Closest to AB: ("+act.P.x+","+act.P.y+") with a distance of "+
      Math.sqrt( distance_from_segment( act.A, act.B, act.P ) )+"<br \/>";
  }
  else
  {
    text += "No points in ABC<br \/>";
  }

  for ( var i = 0; i < act.sub.length; i++ )
  {
    var s = act.sub[i];
    if ( s.cmd == "sub" )
      text += "Removing ("+s.A.x+","+s.A.y+")->("+s.B.x+","+s.B.y+")<br \/>";
    else
    {
      if ( s.auto_removed )
      {
        text += "Trying to add ("+s.A.x+","+s.A.y+")->("+s.B.x+","+s.B.y+")<br \/>";
        text += "-> But auto-removing ("+s.B.x+","+s.B.y+")->("+s.A.x+","+s.A.y+") instead<br \/>";
      }
      else
      {
        text += "Adding ("+s.A.x+","+s.A.y+")->("+s.B.x+","+s.B.y+")<br \/>";
      }
    }
  }

  return text;
}

aos.fun_select_shape();
</script>









































    <h1>The Doom and the WADs</h1>

    <p>Now we have a basis for our tessellation, let's go back to Doom.<br />
    Doom uses WADs to store datas. Those files contains most (but not all)
    of the data defining the game. It contains maps, textures, sprites,
    sounds and elements of the HUD. It does not contain the behaviors (the
    AI, the effect of items, the logic in general), so we will have to provide that
    ourself.
    </p>

    <h2>The format</h2>

    <p>The WAD format is a binary format. Integers are little-endian and strings use
    ASCII (or UTF-8, since its compatible).<br />
    Most of the informations here are taken from the document "The Unofficial Doom Specs v1.666"
    which is a masterpiece of documentation.</p>

    <p>Below is a table giving the description of the terms we will use, along
    with their size.</p>

    <table>
      <tr>
        <td>Name</td><td>Size</td><td>Description</td>
      </tr>

      <tr>
        <td>Byte</td><td>1</td><td>An unsigned integer on 8 bits. Goes from 0 to 255.</td>
      </tr>

      <tr>
        <td>Ushort</td><td>2</td><td>An unsigned integer on 2 bytes. Goes from 0 to (2^16)-1</td>
      </tr>

      <tr>
        <td>Short</td><td>2</td><td>A signed integer on 2 bytes. Goes from -(2^15) to (2^15)-1</td>
      </tr>

      <tr>
        <td>ULong</td><td>4</td><td>An unsigned integer on 4 bytes. Goes from 0 to (2^32)-1</td>
      </tr>

      <tr>
        <td>String8</td><td>8</td><td>A case-insensitive string on 8 bytes, padded with null bytes if needed.
        Because of that, it's NOT a null terminated string (beware the overflow).
        </td>
    </table>

    <p>For people already knowing the content of a WAD, I would like to be clear on one thing:
    I tried to extend types as much as possible. For exemple, the field "left" of a linedef
    contains "-1" when there is no left side. But does it ?<br />
    I decided to say that this field is unsigned, and that the special value 0xffff indicates no left side.
    That way, we kind of double the number of sidedefs we can have.<br />
    It's debatable, but it's what I decided.
    </p>


    <p>A WAD is made of three parts: the header, the directory and the lumps.</p>

    <h3>The header</h3>

    <p>The header is made of 12 bytes:</p>
    <table>
      <tr>
        <td>Name</td><td>Type</td></td><td>Description</td>
      </tr>

      <tr>
        <td>role</td>     <td>4&nbsp;bytes*</td><td>Contains either "PWAD" or "IWAD"</td>
      </tr>

      <tr>
        <td>nb_lumps</td> <td>ULong</td><td>The number of lumps in the directory</td>
      </tr>

      <tr>
        <td>position</td> <td>ULong</td><td>The position of the directory, in bytes, from the beginning
        of this file</td>
      </tr>
    </table>

    <p>
    * This is the only time a string on 4 bytes will appear in the file, so I decided
    not to create a type for this single occurence.
    </p>

    <h3>The directory</h3>
    <p>The directory lists the lumps of the file. Each entry is made of sixteen bytes.</p>

    <table>
      <tr>
        <td>Name</td><td>Type</td><td>Description</td>
      </tr>

      <tr>
        <td>offset</td><td>ULong</td><td>The position of this lump, from the start of this file</td>
      </tr>

      <tr>
        <td>size</td><td>ULong</td><td>The size of this lump, in bytes</td>
      </tr>

      <tr>
        <td>name</td><td>String8</td><td>The name of this lump. <strong>Not unique!</strong></td>
      </tr>
    </table>

    <h3>The lumps</h3>
    <p>
    Each lump has a type, and determining the type of a lump is not
    trivial. Sometime it's based on its name, sometime it's based on its
    position, relative to some other lumps.<br />
    We are going to use some lumps of the WAD, but not all of them.<br />
    </p>

    <h4>Maps start</h4>
    <p>
      In Doom 1, maps have a name in the form of "ExMy", where "x" is the episode (1,2,3
      and 4, for Ultimate Doom), and "y" is the number of the map (starting at 1).<br />
      In Doom 2, maps have a name in the form of "MAPxy", where "xy" describe
      a number going from "01" to "32".<br />
      For simplicity, we will use a slightly different template to identify maps:
    </p>
      <script class="visible_script">
var map_start_regexp = new RegExp("(E[0-9]+M[0-9]+)|(MAP[0-9]+)");
      </script>

    <p>
      Which can be read as
      "(E, followed by any number, followed by M, followed by any number) OR (MAP, followed by any number)".
    </p>

    <p>
    Note that this lump is usually empty. It's only a tag, a beacon. The "meat" of the map
    is in other lumps (see below).
    </p>

    <h4>Maps Lumps</h4>
    <p>
      A "map start" must be followed immediatly by the lumps defining the
      content of the map.<br />
      Here is a complete list of the names of those lumps.
      (In <span class="unused">gray</span> are the lumps we won't talk about).
    </p>

    <ul>
      <li>THINGS</li>
      <li>LINEDEFS</li>
      <li>SIDEDEFS</li>
      <li>VERTEXES</li>
      <li class="unused">SEGS</li>
      <li class="unused">SSECTORS</li>
      <li class="unused">NODES</li>
      <li>SECTORS</li>
      <li class="unused">REJECT</li>
      <li class="unused">BLOCKMAP</li>
    </ul>

    <p>With the logical regular expression:</p>
    <script class="visible_script">var map_lump_regexp = new RegExp("(THINGS)|(LINEDEFS)|(SIDEDEFS)|(VERTEXES)|(SEGS)|(SSECTORS)|(NODES)|(SECTORS)|(REJECT)|(BLOCKMAP)");</script>


    <p>
    Each of those lump contain an array of data. The
    size of the array is based on the size of the lump.<br />
    More precisely, it's "the size of the lump" divided by "the size of an entry".<br />
    </p>

    <h4>THINGS</h4>
    <p>Each entry of this lump is ten bytes long and contains the following:</p>
    <table>
      <tr>
        <td>Name</td><td>Type</td><td>Description</td>
      </tr>

      <tr>
        <td>x</td><td>Short</td><td>The position of the THING on the x axis</td>
      </tr>

      <tr>
        <td>y</td><td>Short</td><td>The position of the THING on the y axis</td>
      </tr>

      <tr>
        <td>angle</td><td>Short</td><td>The angle of the THING, in degrees. Its rounded to the nearest 45 degrees.</td>
      </tr>

      <tr>
        <td>type</td><td>Ushort</td><td>The type of the THING. Possible values are described below</td>
      </tr>

      <tr>
        <td>options</td><td>Ushort</td><td>A bit field indicating the difficulty in which this THING will appear, along with some other informations (see below)</td>
      </tr>
    </table>

    <h4>LINEDEFS</h4>
    <p>Each entry of this lump is fourteen bytes long and contains the following:</p>
    <table>
      <tr>
        <td>Name</td><td>Type</td><td>Description</td>
      </tr>

      <tr>
        <td>from</td><td>Ushort</td><td>The index of the origin vertex of this linedef.</td>
      </tr>

      <tr>
        <td>to</td><td>Ushort</td><td>The index of the destination vertex of this linedef.</td>
      </tr>

      <tr>
        <td>flags</td><td>Ushort</td><td>Flags of the linedef, described below. Unpegged informations are here.</td>
      </tr>

      <tr>
        <td>type</td><td>Ushort</td><td>Type of the linedef, described below. What make a switch a switch is here</td>
      </tr>

      <tr>
        <td>tag</td><td>Ushort</td><td>tag associated with the linedef. When a switch open a distant door, it's because of that. Should match a tag of a (or of multiple) sector(s).</td>
      </tr>

      <tr>
        <td>right</td><td>Ushort</td><td>The index of the right side. There must always be a right side on every linedef.</td>
      </tr>

      <tr>
        <td>left</td><td>Ushort</td><td>The index of the left side. If there is no left side (the line is single-sided) this value must be 0xffff.</td>
      </tr>
    </table>

    <h4>SIDEDEFS</h4>
    <p>Each entry of this lump is thirty bytes long and contains the following:</p>
    <table>
      <tr>
        <td>Name</td><td>Type</td><td>Description</td>
      </tr>

      <tr>
        <td>x_offset</td><td>short</td><td>The x offset of the textures of this side.</td>
      </tr>

      <tr>
        <td>y_offset</td><td>short</td><td>The y offset of the textures of this side.</td>
      </tr>

      <tr>
        <td>upper</td><td>String8</td><td>The name of the texture for the upper part of the wall, or "-" if there is no such texture.</td>
      </tr>

      <tr>
        <td>lower</td><td>String8</td><td>The name of the texture for the lower part of the wall, or "-" if there is no such texture.</td>
      </tr>

      <tr>
        <td>middle</td><td>String8</td><td>The name of the texture for the middle part of the wall, or "-" if there is no such texture.</td>
      </tr>

      <tr>
        <td>sector</td><td>Ushort</td><td>The sector this side is facing.</td>
      </tr>
    </table>


    <h4>VERTEXES</h4>
    <p>Each entry of this lump is four bytes long and contains the following:</p>
    <table>
      <tr>
        <td>Name</td><td>Type</td><td>Description</td>
      </tr>

      <tr>
        <td>x</td><td>Short</td><td>The position of the vertex on the x axis (from left to right)</td>
      </tr>

      <tr>
        <td>y</td><td>Short</td><td>The position of the vertex on the y axix (from bottom to up)</td>
      </tr>
    </table>

    <h4>SECTORS</h4>
    <p>Each entry of this lump is twenty-six bytes long and contains the following:</p>
    <table>
      <tr>
        <td>Name</td><td>Type</td><td>Description</td>
      </tr>

      <tr>
        <td>floor_height</td><td>Short</td><td>The floor' height of this sector.</td>
      </tr>

      <tr>
        <td>ceiling_height</td><td>Short</td><td>The ceiling' height of this sector.</td>
      </tr>

      <tr>
        <td>floor_flat</td><td>String8</td><td>The image displayed on the floor.</td>
      </tr>

      <tr>
        <td>ceiling_flat</td><td>String8</td><td>The image displayed on the ceiling.</td>
      </tr>

      <tr>
        <td>lightlevel</td><td>Ushort</td><td>The light level of this sector. Despite being on 2 bytes, its value range from 0 to 255, and only 32 shades are available (0 to 7 are the same shade).</td>
      </tr>

      <tr>
        <td>special</td><td>Ushort</td><td>The "type" of the sector. Sectors doing damage, being secret and so: it's here. See below.</td>
      </tr>

      <tr>
        <td>tag</td><td>Ushort</td><td>A tag, to operate the sector at distance. When a switch open a distant door, a tag is involved.</td>
      </tr>
    </table>

    <h4>PNAMES</h4>

    <p>List the patches of this WAD. Only patches listed there can be used
    by textures. This lumps starts with an ULong, containing the number
    of patches, followed by the names of the patches (String8).</p>


    <h4>Images</h4>

    <p>I use this as a generic term. In Doom, several formats of image coexist.
    They all share some common properties, the major one being that they all use
    paletted colors. At any time, Doom will display only 256 colors on screen,
    including the menus and the difference shades in the 3D* view.</p>

    <p>*I know Doom isn't in 3D. Thank you.</p>

    <h5>Flats</h5>

    <p>Those are the simplest form of image. Each flat is a lump made of exactly 4096 bytes.
    It contains an image of 64*64 (=4096) pixels.
    Each flat, to be a considered a flat, must be after (not necessarily immediatly after)
    a lump named F_START and before (but not necessarily immediatly before) a lump named
    F_END. Those two lumps, F_START and F_END, does not contain datas, they are markers.</p>

    <h5>Sprites and patches</h5>

    <p>Sprites and patches can contain transparent pixels and, because of that,
    they are more complicated. There is no index, in the 256 possible values of a byte,
    that indicate a transparent color. Each color is opaque in the palette.<br />
    To achieve transparency, Doom just don't draw some areas of the images.<br />
    Explicitely, sprites (and patches) are made of columns, and each column is a list
    of small posts/strips/bands of pixels.<br />
    By leaving areas between posts, you can achieve a transparency effect.<br />
    </p>

    <p>The format of a sprite (and a patch) starts like this:</p>

    <table>
      <tr>
        <td>Name</td><td>Type</td><td>Description</td>
      </tr>

      <tr>
        <td>width</td><td>Ushort</td><td>The width of the sprite/patch.</td>
      </tr>

      <tr>
        <td>height</td><td>Ushort</td><td>The height of the sprite/patch.</td>
      </tr>

      <tr>
        <td>left_offset</td><td>Short</td><td rowspan="2">Those two offsets are not to be used directly and follow complex (for me) rules
    described in details in the document "The Unofficial Doom Specs v1.666".
    <strong>I do not understand them entirely</strong>, so I'll not pretend I can teach
    that to you. But we don't NEED that for what will follow, at worst we will
    have a visual bug that we will fix later.</td>
      </tr>

      <tr>
        <td>top_offset</td><td>Short</td>
      </tr>
    </table>

    <p>Then follows N entries, where N is the width of the sprite/patch. Each entry
    is as follow:</p>

    <table>
      <tr>
        <td>Name</td><td>Type</td><td>Description</td>
      </tr>

      <tr>
        <td>start</td><td>ULong</td><td>The start of the column, in bytes, from the beginning of
        the <strong>lump</strong></td>
      </tr>
    </table>

    <p>Each column is made of a sequence of posts. It's not prefixed
    by the number of posts, but ends with a specific post.<br />
    If you ever programmed in C, you already encountered structures like this: any "null-terminated string"
    is exactly that, not prefixed by its length but ending with a specific value.</p>

    <table>
      <tr>
        <td>Name</td><td>Type</td><td>Description</td>
      </tr>

      <tr>
        <td>row</td><td>Byte</td><td>The row at which this post is to be drawn <strong>or the special
        value 0xff to terminate this column.</strong></td>
      </tr>

      <tr>
        <td>length</td><td>Byte</td><td>The length of this post, downward.</td>
      </tr>

      <tr>
        <td>-</td><td>Byte</td><td>Unused byte.</td>
      </tr>

      <tr>
        <td>pixel</td><td>Byte*</td><td>There is as many of those pixels as
        the length of the post. They are just indexes.</td>
      </tr>

      <tr>
        <td>-</td><td>Byte</td><td>Unused byte.</td>
      </tr>
    </table>



    <h5>Textures</h5>

    <p>Textures are built as a collection of patches. Moreover, they are
    not scattered in multiple lumps, one per texture, but instead contained
    in one (or two) lump(s) named "TEXTURE1" (and/or TEXTURE2).<br />
    There is a rational behind this decision: as each texture uses a variable
    number of patches, their sizes are variable as well.<br />
    </p>

    <p>The format of TEXTURE1 (and TEXTURE2) is as follow:</p>
    <table>
      <tr>
        <td>Name</td><td>Type</td><td>Description</td>
      </tr>

      <tr>
        <td>nb_textures</td><td>ULong</td><td>The number of textures in that lump.</td>
      </tr>

      <td>
        <td>offsets</td><td>nb_textures of ULong</td>Offsets of the textures definitions,
        from the beginning of the lump (NOT from the beginning of the file).</td>
      </tr>
    </table>

    <p>Each texture definition is as follow:</p>

    <table>
      <tr>
        <td>Name</td><td>Type</td><td>Description</td>
      </tr>

      <tr>
        <td>name</td><td>String8</td><td>The name of the texture (padded with null bytes if
        needed)</td>
      </tr>

      <tr>
        <td>-</td><td>Ushort</td><td>Unused field. Always 0.</td>
      </tr>

      <tr>
        <td>-</td><td>Ushort</td><td>Another unused field. Always 0 too.</td>
      </tr>

      <tr>
        <td>width</td><td>Ushort</td><td>Width of the texture.</td>
      </tr>

      <tr>
        <td>height</td><td>Ushort</td><td>Height of the texture. In Doom, a height bigger than 128
        would lead to graphical bugs.</td>
      </tr>

      <tr>
        <td>-</td><td>Ushort</td><td>A third unused field. Always 0 too.</td>
      </tr>

      <tr>
        <td>-</td><td>Ushort</td><td>A fourth unused field. Always 0 too.</td>
      </tr>

      <tr>
        <td>nb_patches</td><td>Ushort</td><td>The number of patches used by this texture.</td>
      </tr>
    </table>

    <p>Then follows "nb_patches" patch descriptors. Each descriptor is as follow:</p>

    <table>
      <tr>
        <td>Name</td><td>Type</td><td>Description</td>
      </tr>

      <tr>
        <td>x_offset</td><td>Short</td><td>Position on the x axis, where to blit this patch, from left to right.</td>
      </tr>

      <tr>
        <td>y_offset</td><td>Short</td><td>Position on the y axis, from top to bottom.</td>
      </tr>

      <tr>
        <td>id</td><td>Ushort</td><td>The index of the patch in the PNAMES lump</td>
      </tr>

      <tr>
        <td>-</td><td>Ushort</td><td>An yet another unused field. Always ... 1.</td>
      </tr>

      <tr>
        <td>-</td><td>Ushort</td><td>And a last unused field. Always 0.</td>
      </tr>
    </table>

    <p>It's quite a lot of sub-type and sub-sub-type, but it's mandatory to parse this
    to extract textures from Doom. As I said earlier, it's the most complicated image
    format in Doom.</p>

    <h4>PLAYPAL</h4>

    <p>The palettes used by Doom. It fourteen palettes, each of them containing
    256 entries, each entry being 3 bytes long, encoding red, green and blue components,
    in that order. No alpha.</p>

    <h4>COLORMAP</h4>

    <p>The purpose of this lump is to re-map colors to darker tones. It's
    the trick used by Doom to display sectors of different light levels
    while keeping 256 colors only on the screen.<br />
    It contains 34 arrays of 256 bytes, whose purpose will be explained later.
    </p>



    <h2>Parsing the file</h2>

    <p>With what is above, we can start to write a parser for WADs. However, you
    must know that Doom is capable of using more than one WAD (hence the use of PWADs).<br />
    Datas from the new WAD will overwrite datas from the previous ones, but as wads entries
    aren't unique, merging wads is not as obvious as one may think.</p>

    <p>The good news is that we can (and we will) abstract this problem away. We can
    have a WAD holder that we will feed with a stream of WADs, and then we will ask it
    questions like "what is the list of available maps", "what are the lumps of those maps" etc.
    </p>

    <p>For now, the implementation of this abstraction will only handle one WAD,
    but it's only for the sake of simplicity and incremental programming</p>

    <p>I'll skip a part of this process: how we acquire an ArrayBuffer.<br />
    The reason why, it's because here I acquire it from an &lt;input&gt;, but you may also acquire
    it from the network or, I guess in a stand-alone application using Javascript, from a file etc.<br />
    Finally, all of this is REALLY Javascript specific, and the algorithms I describe here
    can be implemented in any(/most) language.</p>

    <p>
    As the set of functionnalities we need to implement is a bit long, I decided
    to split it in several parts, to have time to comment each of them and to
    not throw at your face a big block of code and "deal with it".<br />
    But the consequence of the is that I cannot hide all of that in a function,
    as I should do.</p>

    <p>That being said, let's start the implementation.</p>

    <h3>Low level access</h3>
    <p>We need a way to parse the file, and for that we need a standard way of accessing it.</p>

    <script class="visible_script">
function create_file_reader( buffer, start, length )
{
  if ( ! start ) start = 0;
  if ( ! length ) length = buffer.byteLength;

  var location = 0;
  function forward(n) {
    location = location + n;
    return location - n;
  }

  var res = {};
  var dv = new DataView( buffer, start, length );
  res.read_byte = () => dv.getUint8( forward(1) );
  res.read_ushort = () => dv.getUint16( forward(2), true );
  res.read_short = () => dv.getInt16( forward(2), true );
  res.read_ulong = () => dv.getUint32( forward(4), true );
  res.read_stringN = function( n )
  {
    var str = "";
    for ( var i = 0; i < n; i++ )
    {
      var c = dv.getUint8( location + i );
      if ( c != 0 )
        str += String.fromCharCode( c ).toUpperCase();
      else
        break;
    }
    location += n;
    return str;
  }
  res.read_string8 = () => res.read_stringN( 8 );

  res.seek = function( n ) { location = n; };
  res.tell = () => location;
  res.size = () => length;

  return res;
}</script>

    <p>
    (I expect optimizations from the compiler for simple cases).<br />
    Let's unfold that:</p>
    <ul>
      <li>The function takes a mandatory parameter, which is the buffer, and an optional parameter which
      is the starting point of the reading. This second parameter will allow us to
      create sub-reader, and that will be useful when we will parse textures.</li>
      <li>For every reading we must extract a certain number of bytes and move
      the cursor forward. We have a function "forward" that will return the old
      value (where we must read) and update the position.</li>
      <li>
      Javascript reads things in big endian by default. I guess it's to copycat
      Java. Whatever the reason is, we still need to read things in little endian.<br />
      By chance, the methods of the DataView take an optional parameter which let us
      read in little endian.</li>
      <li>
      We will often need to read those String8 values, so I created a function
      dedicated to this type. Those strings are case insensitive, so I convert
      everything to big endian right away.</li>
      <li>Finally, we need to be able to move the cursor to arbitrary positions
      (we will jump a lot).</li>
    </ul>

    <h3>Mid-level access</h3>
    <p>We implemented the low level access, let's go for the mid-level access:
    extraction of the header and of the directory<br />
    As easy as it may seems to be, it will be a sign we are
    on the right track, a proof that we have the hand on the file, that
    we extracted integer with the correct endianess and so forth.
    </p>


    <script class="visible_script">function create_wad( buffer )
{
  var res = {};
  res.buffer = buffer;
  res.reader = create_file_reader( buffer );
  return res;
}

function read_wad_header( wad )
{
  var reader = wad.reader;

  wad.header = {};
  wad.header.type = reader.read_stringN(4);
  switch(wad.header.type)
  {
    case "IWAD":
    case "PWAD":
      break;
    default:
      wad.header = null;
      return false;
  }
  wad.header.nb_entries = reader.read_ulong();
  wad.header.offset = reader.read_ulong();

  return true;
}

function read_wad_directory( wad )
{
  var reader = wad.reader;

  wad.directory = [];
  reader.seek( wad.header.offset );
  for ( var i = 0; i < wad.header.nb_entries; i++ )
  {
    var lump = {};
    lump.offset = reader.read_ulong();
    lump.size = reader.read_ulong();
    lump.name = reader.read_string8();
    wad.directory.push( lump );
  }

  wad.open_lump = function ( lump )
  {
    return create_file_reader( wad.buffer, lump.offset, lump.size );
  }
}
</script>


    <h4>Insert a WAD</h4>
    <p>Now, if we want to test that, we will need ... a wad.<br />
    I cannot provide DOOM.WAD, for legal reasons, but one may argue that I could provide
    the shareware. I am not even sure of that, but in any case I consider this file
    as already big enough as is. You'll have to obtain a WAD yourself, it being freedoom/freedoom2,
    or the shareware, or any other IWAD, by means I'll not describe here.<br />
    Once it's done, please input it here:
    </p>

    <input type="file" id="input_for_wad" />
    <script>

    var input_for_wad = document.getElementById("input_for_wad");
    input_for_wad.onchange = function()
    {
      var fr = new FileReader();
      fr.onload = function( ) {
        var wad = create_wad( fr.result );
        read_wad_header( wad );

        var status = document.getElementById("input_for_wad_status");
        if ( wad.header )
        {
          document.body.classList.add("wad_provided");
          status.textContent = "WAD loaded successfully";

          for ( var i = 0; i < on_wad_loaded.length; i++ )
            on_wad_loaded[i]( wad );
        }
        else
        {
          status.textContent = "File is not a valid WAD";
        }
      }
      fr.readAsArrayBuffer( this.files[0] );
    }
    </script>

    <p id="input_for_wad_status">Status: no input WAD</p>

    <p>If you don't, you won't be able to see examples "live".</p>


    <div class="need_wad">
      <script>
      on_wad_loaded.push( function( wad ) {
        var h = document.getElementsByClassName("parsing_wad-extracted_header")[0];
        var d = document.getElementsByClassName("parsing_wad-extracted_directory")[0];

        h.textContent = "Type: "+wad.header.type+", directory size: "+wad.header.nb_entries+", directory location: "+wad.header.offset;
      } )
      </script>
      This are the informations obtained by using the previous code:
      <div class="parsing_wad-extracted_header"></div>
      <div class="parsing_wad-extracted_directory"></div>
      <p>That's a lot of lumps !</p>
    </div>

    <p>
      We now need to put lumps in different buckets according to their type.<br />
      I implemented that with a state-machine so I can do all the sorting in
      only one pass, but you can do it however you want.<br />
      I split them in the following buckets:
    </p>

    <ul>
      <li>maps</li>
      <li>sprites</li>
      <li>patches</li>
      <li>flats</li>
    </ul>

    <p>"maps" is a special bucket in that each entry will contain all the lumps defining the map.</p>

<script class="visible_script">function put_lumps_in_buckets( wad )
{
  wad.maps = {};
  wad.sprites = {};
  wad.patches = {};
  wad.flats = {};
  wad.by_names = {};
  wad.textures = {};

  var current_map = null;
  var state = 0;
  for ( i = 0; i < wad.directory.length; i++ )
  {
    var lump = wad.directory[i];
    var lump_name = lump.name;

    wad.by_names[lump_name] = lump;

    switch( state )
    {
      case 1: // reading map lumps
        if ( map_lump_regexp.test( lump_name ) )
        {
          current_map[lump_name] = lump;
          break;
        }
        else
        {
          current_map = null;
          state = 0;
        }
        // NO BREAK HERE !
        // so we default to initial case
      case 0: // initial
        if ( map_start_regexp.test( lump_name ) )
        {
          current_map = {};
          wad.maps[lump_name] = current_map;
          state = 1;
        }
        else if ( lump_name == "S_START" )
        {
          state = 2;
        }
        else if ( lump_name == "P_START" )
        {
          state = 3;
        }
        else if ( lump_name == "F_START" )
        {
          state = 4;
        }
        break;
      case 2: // sprites
        if ( lump_name == "S_END" )
          state = 0;
        else
          wad.sprites[lump_name] = lump;
        break;
      case 3: // patches
        if ( lump_name == "P_END" )
          state = 0;
        else if ( lump.size > 0 )
          wad.patches[lump_name] = lump;
        break;
      case 4: // flats
        if ( lump_name == "F_END" )
          state = 0;
        else if ( lump.size > 0 )
          wad.flats[lump_name] = lump;
        break;
    }
  }
}
</script>

    <div class="need_wad">

    </div>
    <script>
    on_wad_loaded.push( function( wad ) {

    read_wad_directory( wad );
    put_lumps_in_buckets( wad );


    } );
    </script>

    <h3>High-level access</h3>

    <p>All of that is fine, but we haven't give any semantic to those lumps.<br />
    We could do that for all of them at once, but it would be kind of pointless:
    after all, the player will not play ALL the map simultaneously, and maybe
    some image will not be used immediatly either.<br />
    </p>

    <p>
    We will use lazy loading: each lump will have a field called "extracted" that,
    if it exists, will contain the extracted data of the lump.<br />
    And by "extracted data" I really mean the fields given above. We will let informations
    inside the file for as long as we can, and use the directory as a manifest to only
    extract what we need, when we need it.<br />
    </p>

    <p>We need functions to extract the lumps as described above.
    For map lumps, each function will take as parameter an access
    to the lump and will extract one entry of it.</p>

<script class="visible_script">
function extract_thing( r )
{
  var res = {};
  res.x       = r.read_short();
  res.y       = r.read_short();
  res.angle   = r.read_short();
  res.type    = r.read_ushort();
  res.options = r.read_ushort();

  /* we should de "angle % 360". But it's Javascript,
  so if angle is less than zero it will yield a negative result.*/
  /* Also, there is no "Math.mod" that would give the correct result.*/

  var mod = (a,b) => ((a%b)+b)%b;
  res.angle = mod( res.angle, 360 );
  res.angle = 45 * Math.floor( res.angle / 45 );

  return res;
}

function extract_linedef( r )
{
  var res = {};

  res.from  = r.read_ushort();
  res.to    = r.read_ushort();
  res.flags = r.read_ushort();
  res.types = r.read_ushort();
  res.tag   = r.read_ushort();
  res.right = r.read_ushort();
  res.left  = r.read_ushort();

  return res;
}

function extract_sidedef( r )
{
  var res = {};

  res.x_offset  = r.read_short();
  res.y_offset  = r.read_short();
  res.upper     = r.read_string8();
  res.lower     = r.read_string8();
  res.middle    = r.read_string8();
  res.sector    = r.read_ushort();

  return res;
}

function extract_vertex( r )
{
  var res = {};

  res.x = r.read_short();
  res.y = r.read_short();

  return res;
}

function extract_sector( r )
{
  var res = {};

  res.floor_height    = r.read_short();
  res.ceiling_height  = r.read_short();
  res.floor_flat      = r.read_string8();
  res.ceiling_flat    = r.read_string8();
  res.lightlevel      = r.read_ushort();
  res.special         = r.read_ushort();
  res.tag             = r.read_ushort();

  return res;
}
</script>

    <p>Those functions only extract one entry. We need to complement them
    with something to extract all entries.</p>
<script class="visible_script">
function extract_many( r, extract_one )
{
  var res = [];
  if ( r.size() == 0 )
    return res;

  res.push( extract_one( r ) );

  var element_size = r.tell();
  var nb_elements = Math.floor( r.size() / element_size );
  for ( var i = 1; i < nb_elements; i++ )
    res.push( extract_one( r ) );

  return res;
}

function extract_things   ( r ) { return extract_many( r, extract_thing ); }
function extract_linedefs ( r ) { return extract_many( r, extract_linedef ); }
function extract_sidedefs ( r ) { return extract_many( r, extract_sidedef ); }
function extract_vertexes ( r ) { return extract_many( r, extract_vertex ); }
function extract_sectors  ( r ) { return extract_many( r, extract_sector ); }
</script>

    <p>Let's extract the rest of the lumps</p>

<script class="visible_script">
function extract_pnames( r )
{
  var res = [];

  var nb = r.read_ulong();
  for ( var i = 0; i < nb; i++ )
    res.push( r.read_string8() );

  return res;
}

function extract_textures( r )
{
  var res = {};
  var nb_textures = r.read_ulong();
  var offsets = [];

  for ( var i = 0; i < nb_textures; i++ )
    offsets.push( r.read_ulong() );

  for ( var i = 0; i < nb_textures; i++ )
  {
    r.seek( offsets[i] );

    var texture = {};
    texture.name = r.read_string8();
    r.read_ushort(); // skip
    r.read_ushort(); // skip
    texture.width = r.read_ushort();
    texture.height = r.read_ushort();
    r.read_ushort(); // skip
    r.read_ushort(); // skip

    var nb_patches = r.read_ushort();
    texture.patches = [];
    for( var j = 0; j < nb_patches; j++ )
    {
      var patch = {};
      patch.x_offset = r.read_short();
      patch.y_offset = r.read_short();
      patch.id = r.read_ushort();
      r.read_ushort(); // unused
      r.read_ushort(); // unused
      texture.patches.push( patch );
    }

    res[texture.name] = texture;
  }

  return res;
}

function extract_playpal( r )
{
  var res = [];
  var k = 0;

  for ( var i = 0; i < 14; i++ )
  {
    var palette = [];
    for ( var j = 0; j < 256; j++ )
    {
      var color = {};
      color.r = r.read_byte();
      color.g = r.read_byte();
      color.b = r.read_byte();
      palette.push( color );
    }
    res.push( palette );
  }

  return res;
}

function extract_colormap( r )
{
  var res = [];

  for ( var i = 0; i < 34; i++ )
  {
    var remap = [];
    for ( var j = 0; j < 256; j++ )
      remap.push( r.read_byte() );

    res.push( remap );
  }

  return res;
}

function extract_picture( r )
{
  var res = {};

  var width = r.read_ushort();

  res.height = r.read_ushort();
  res.left_offset = r.read_short();
  res.top_offset = r.read_short();
  res.columns = new Array( width );

  var starts = new Array( width );
  for ( var i = 0; i < width; i++ )
    starts[i] = r.read_ulong();

  for ( var i = 0; i < width; i++ )
  {
    res.columns[i] = [];

    r.seek( starts[i] );
    while( true )
    {
      var row = r.read_byte();
      if ( row == 0xff )
        break;

      var band = { row: row, pixels: [] };
      res.columns[i].push( band );

      var length = r.read_byte();
      r.read_byte(); // unused
      for ( var j = 0; j < length; j++ )
        band.pixels.push( r.read_byte() );
      r.read_byte(); // unused
    }
  }

  return res;
}

</script>

  <p>All of these functions (and the other of the same kind that will come),
  are invoked through the function "ensure_extracted" below:</p>

<script class="visible_script">

function ensure_extracted( wad, lump, extract_function )
{
  if ( lump.extracted == null )
  {
    var r = wad.open_lump( lump );
    lump.extracted = extract_function( r );
    if ( lump.extracted == null )
      throw new Error("Failed to extract lump "+lump.name);
  }

  return lump.extracted;
}
</script>

    <p>We need one more thing before we can test our images extraction:
    a way to represent those images, and to convert this representation
    into something usable by Javascript.</p>

    <p>I did that with an "opt_pixmap". It contains shorts, the lower byte being used to
    store the index, the higher byte indicating if this pixel has been set.
    It would be very hard to store each pixel on 9 bits (and very inefficient
    in many places), hence this two bytes per pixel.</p>

<script class="visible_script">
function create_opt_pixmap( width, height )
{
  var res = {};
  res.w = width;
  res.h = height;
  res.buf = new Uint16Array( width * height );

  res.set = ( x, y, index ) => res.buf[y*width+x] = (1<<8)|index;
  res.has = ( x, y ) => res.buf[y*width+x] & (1<<8);
  res.get = ( x, y ) => res.buf[y*width+x];

  res.blit = function( dst_x, dst_y, other )
  {
    var w = Math.min( other.w, res.w - dst_x );
    var h = Math.min( other.h, res.h - dst_y );

    for ( var i = 0; i < h; i++ )
    {
      for ( var j = 0; j < w; j++ )
      {
        var src = other.get( j, i );
        if ( src >= (1<<8) )
          res.set( j+dst_x, i+dst_y, src & 0xff );
      }
    }
  }

  res.to_imageData = function( palette, colormap )
  {
    var d = new ImageData( width, height );
    var buf = d.data;

    for ( var i = 0; i < height; i++ )
    {
      for ( var j = 0; j < width; j++ )
      {
        var where = i*width+j;
        var index = res.buf[where];
        if ( index >= (1<<8) )
        {
          var reindex = colormap[index & 0xff];
          var color = palette[reindex];

          buf[where*4+0] = color.r;
          buf[where*4+1] = color.g;
          buf[where*4+2] = color.b;
          buf[where*4+3] = 255;
        }
      }
    }
    return d;
  }

  return res;
}
</script>

    <h4>Displaying the content</h4>
    <p>First, we should try to display flats (as they are the simplest structure,
    it will remove possible sources of errors).</p>

<script class="visible_script">
function flat_to_opt_pixmap( r )
{
  var opt_pixmap = create_opt_pixmap( 64, 64 );
  for ( var i = 0; i < 64; i++ )
  {
    for ( var j = 0; j < 64; j++ )
    {
      opt_pixmap.set( j, i, r.read_byte() );
    }
  }

  return opt_pixmap;
}
</script>

    <div class="data_viewer need_wad">
      <select id="display_flats-select"></select>
      <canvas id="display_flats-canvas" width="64" height="64"></canvas>
      <script>
      on_wad_loaded.push( function( wad )
      {
        var playpal = ensure_extracted( wad, wad.by_names["PLAYPAL"], extract_playpal );
        var colormap = ensure_extracted( wad, wad.by_names["COLORMAP"], extract_colormap );


        var select = document.getElementById("display_flats-select");
        var canvas = document.getElementById("display_flats-canvas");
        var ctx = canvas.getContext("2d");

        for ( var i in wad.flats )
        {
          var flat = wad.flats[i];
          var option = document.createElement("option");
          option.textContent = i;
          select.appendChild(option);
        }

        select.oninput = function()
        {
          var name = select.value;
          var r = wad.open_lump( wad.flats[name] );
          var image = flat_to_opt_pixmap( r );

          ctx.putImageData( image.to_imageData( playpal[0], colormap[0] ), 0, 0 );
        }

        select.oninput();
      });
      </script>
    </div>

    <p>Then, the next step of complexity: sprites (and patches, but we aren't going
    to display those, not directly).</p>

<script class="visible_script">

function draw_picture_on_opt_pixmap( picture, opt_pixmap, dst_x, dst_y )
{
  for ( var i = 0; i < picture.columns.length; i++ )
  {
    // yes, we can optimize this
    if ( dst_x + i < 0 )
      continue;

    if ( dst_x + i >= opt_pixmap.w )
      break;

    var bands = picture.columns[i];
    for ( var j = 0; j < bands.length; j++ )
    {
      var band = bands[j];
      var row = band.row;
      var pixels = band.pixels;

      for ( var k = 0; k < pixels.length; k++ )
      {
        // same here, optimizations are possible
        if ( dst_y + k + row < 0 )
          continue;

        if ( dst_y + k + row >= opt_pixmap.h )
          break;

        opt_pixmap.set( dst_x + i, dst_y + k + row, pixels[k] );
      }
    }
  }
}

function sprite_to_opt_pixmap( picture )
{
  var width = picture.columns.length;
  var height = picture.height;
  var opt_pixmap = create_opt_pixmap( width, height );

  draw_picture_on_opt_pixmap( picture, opt_pixmap, 0, 0 );

  return opt_pixmap;
}
</script>

    <div class="need_wad data_viewer">
      <select id="display_sprites-select" multiple="multiple"></select>
      <canvas id="display_sprites-canvas" width="256" height="256"></canvas>
      <canvas id="display_sprites-pattern" style="display: none;"></canvas>
      <script>
      on_wad_loaded.push( function( wad )
      {
        var playpal = ensure_extracted( wad, wad.by_names["PLAYPAL"], extract_playpal );
        var colormap = ensure_extracted( wad, wad.by_names["COLORMAP"], extract_colormap );

        var select = document.getElementById("display_sprites-select");
        var canvas = document.getElementById("display_sprites-canvas");
        var pattern = document.getElementById("display_sprites-pattern");

        var ctx = canvas.getContext("2d");
        var pattern_ctx = pattern.getContext("2d");

        for ( var i in wad.sprites )
        {
          var flat = wad.sprites[i];
          var option = document.createElement("option");
          option.textContent = i;
          select.appendChild(option);
        }

        select.children[0].selected = "selected";

        select.oninput = function()
        {
          var name = select.value;
          ensure_extracted( wad, wad.sprites[name], extract_picture );
          var image = sprite_to_opt_pixmap( wad.sprites[name].extracted );

          ctx.clearRect( 0, 0, 256, 256 );
          var x = 128 - image.w / 2;
          var y = 128 - image.h / 2;
          ctx.strokeStyle="gray";
          ctx.beginPath();
          ctx.moveTo( 128, 0   );
          ctx.lineTo( 128, 256 );
          ctx.moveTo( 0  , 128 );
          ctx.lineTo( 256, 128 );
          ctx.stroke();
          ctx.closePath();

          pattern.width = image.w;
          pattern.height = image.h;
          pattern_ctx.clearRect( 0, 0, pattern.width, pattern.height );
          pattern_ctx.putImageData( image.to_imageData( playpal[0], colormap[0] ), 0, 0 );


          ctx.drawImage( pattern, x, y );
        }

        select.oninput();
      });
      </script>
    </div>


    <p>We prepared the drawing of textures by separating the creation of the
    opt_pixmap from the drawing of the picture onto it.</p>

<script class="visible_script">
function texture_to_opt_pixmap( texture, wad )
{
  var pnames = ensure_extracted( wad, wad.by_names["PNAMES"], extract_pnames );
  var opt_pixmap = create_opt_pixmap( texture.width, texture.height );
  for ( var i = 0; i < texture.patches.length; i++ )
  {
    var patch = texture.patches[i];
    var patch_name = pnames[patch.id];
    var picture = ensure_extracted( wad, wad.patches[patch_name], extract_picture );

    draw_picture_on_opt_pixmap( picture, opt_pixmap, patch.x_offset, patch.y_offset );
  }

  return opt_pixmap;
}
</script>

    <div class="need_wad data_viewer">
      <select id="display_textures-select" multiple="multiple"></select>
      <canvas id="display_textures-canvas" width="256" height="256"></canvas>
      <script>
      on_wad_loaded.push( function( wad )
      {
        var atlas = {};

        var tex1 = wad.by_names["TEXTURE1"];
        ensure_extracted( wad, tex1, extract_textures );

        for ( var k in tex1.extracted )
          atlas[k] = tex1.extracted[k];

        var tex2 = wad.by_names["TEXTURE2"];
        if ( tex2 )
        {
          ensure_extracted( wad, tex2, extract_textures );
          for ( var k in tex2.extracted )
            atlas[k] = tex2.extracted[k];
        }

        var playpal = ensure_extracted( wad, wad.by_names["PLAYPAL"], extract_playpal );
        var colormap = ensure_extracted( wad, wad.by_names["COLORMAP"], extract_colormap );

        var select = document.getElementById("display_textures-select");
        var canvas = document.getElementById("display_textures-canvas");

        var ctx = canvas.getContext("2d");

        for ( var i in atlas )
        {
          var option = document.createElement("option");
          option.textContent = i;
          select.appendChild(option);
        }

        select.children[0].selected = "selected";

        select.oninput = function()
        {
          var name = select.value;
          var image = texture_to_opt_pixmap( atlas[name], wad );

          ctx.clearRect( 0, 0, 256, 256 );
          var x = 128 - image.w / 2;
          var y = 128 - image.h / 2;
          ctx.putImageData( image.to_imageData( playpal[0], colormap[0] ), x, y );
        }

        select.oninput();
      });
      </script>
    </div>

    <p>Now, as we have several kind of images (sprites, flats, textures),
    it would be nice to have a way to access any of them with a common interface.</p>

<script class="visible_script">
function create_wad_images_manager( wad )
{
  var images = {};
  images.S = {};
  images.T = {};
  images.F = {};

  var all_textures = {};
  var add_textureX = function( textures )
  {
    if ( textures == null )
      return;
    ensure_extracted( wad, textures, extract_textures );
    for ( k in textures.extracted )
      all_textures[k] = textures.extracted[k];
  }

  for ( var i = 0; i < 10; i++ )
    add_textureX( wad.by_names["TEXTURE"+i] );

  var ensure_image = function ( key )
  {
    var source = null;
    switch( key.type )
    {
      case 'S': source = images.S; break;
      case 'T': source = images.T; break;
      case 'F': source = images.F; break;
      default:
        return null;
    }

    var name = key.name;
    var res = source[name];
    if ( res == null )
    {
      var fun = null;
      switch( key.type )
      {
        case 'S':
          res = sprite_to_opt_pixmap( ensure_extracted( wad, wad.sprites[name], extract_picture ) );
          break;
        case 'T':
          res = texture_to_opt_pixmap( all_textures[name], wad );
          break;
        case 'F':
        {
          var r = wad.open_lump( wad.flats[name] );
          res = flat_to_opt_pixmap( r );
        }
        break;
      }
      source[name] = res;
    }

    return res;
  }

  return ensure_image;
}
</script>

    <p>For the last part of this chapter, let's extract and display maps.
    We can (finally!) use the first chapter to tessellate them.</p>

    <p>For that we need to "build" the map we want:</p>

<script class="visible_script">
function build_map( wad, name )
{
  var base = wad.maps[name];
  var res = {};

  res.THINGS = ensure_extracted( wad, base.THINGS, extract_things );
  res.LINEDEFS = ensure_extracted( wad, base.LINEDEFS, extract_linedefs );
  res.SIDEDEFS = ensure_extracted( wad, base.SIDEDEFS, extract_sidedefs );
  res.VERTEXES = ensure_extracted( wad, base.VERTEXES, extract_vertexes );
  res.SECTORS = ensure_extracted( wad, base.SECTORS, extract_sectors );

  return res;
}
</script>

    <p>Let's start with this: for each linedef in the map, we will draw it on a canvas
    with a color determined by a custom function. If this function returns nothing,
    it means that the line should not be drawn. Otherwise, the function can use
    whatever method it wants to decide the color of the line.</p>

    <p>For example, it can decides the following: (the first item meeting the criterion is retained)</p>

    <ul>
      <li>If the line is single sided, the line should be <span style="color: darkred">dark red</span></li>
      <li>If the line is a basic door, the line should be <span style="color: green">Green</span></li>
      <li>If the line one of the sector is a secret, the line should be <span style="color: fuchsia">fuchsia</span></li>
      <li>If the two sector of the line aren't the same height, either for the floor or for the ceiling (or both) the line should be <span style="color: orange">orange</span></li>
      <li>Otherwise the line should not be drawn.</li>
    </ul>

    <p>The function is as follow:</p>

<script class="visible_script">
var LINEDEF_COLOR_SINGLE_SIDED = "Darkred";
var LINEDEF_COLOR_DOOR = "Green";
var LINEDEF_COLOR_SECRET = "Fuchsia";
var LINEDEF_COLOR_CHANGE_HEIGHT = "Orange";

function decide_line_color( map, line_id )
{
  var linedef = map.LINEDEFS[line_id];
  if ( linedef.left == 0xffff ) return LINEDEF_COLOR_SINGLE_SIDED;
  if ( linedef.types == 1 ) return LINEDEF_COLOR_DOOR;

  var sector1_id = map.SIDEDEFS[linedef.right].sector;
  var sector2_id = map.SIDEDEFS[linedef.left].sector;

  var sector1 = map.SECTORS[sector1_id];
  var sector2 = map.SECTORS[sector2_id];

  if ( sector1.special == 9 || sector2.special == 9 )
    return LINEDEF_COLOR_SECRET;

  if ( sector1.floor_height != sector2.floor_height || sector1.ceiling_height != sector2.ceiling_height )
    return LINEDEF_COLOR_CHANGE_HEIGHT;

  return null;
}
</script>

    <p>Let's apply this to the first map of the WAD</p>

    <div class="need_wad center">
      <canvas width="512" height="512" id="show_map_linedefs_1"></canvas>
    </div>

    <script>
    on_wad_loaded.push( function( wad ) {
      var canvas = document.getElementById("show_map_linedefs_1");
      var ctx = canvas.getContext("2d");
      ctx.fillStyle = "#f0f0f0";
      ctx.fillRect( 0, 0, canvas.width, canvas.height );

      var map_name = null;
      for ( var k in wad.maps ) { map_name = k; break; }

      var map = build_map( wad, map_name );

      var min_x;
      var min_y;
      var max_x;
      var max_y;

      min_x = max_x = map.VERTEXES[0].x;
      min_y = max_y = map.VERTEXES[0].y;
      for ( var i = 1; i < map.VERTEXES.length; i++ )
      {
        var vertex = map.VERTEXES[i];
        if ( vertex.x < min_x )
          min_x = vertex.x;
        else if ( vertex.x > max_x )
          max_x = vertex.x;

        if ( vertex.y < min_y )
          min_y = vertex.y;
        else if ( vertex.y > max_y )
          max_y = vertex.y;
      }

      var size_x = max_x - min_x;
      var size_y = max_y - min_y;

      var scale_x = canvas.width / (size_x*1.0);
      var scale_y = canvas.height / (size_y*1.0);

      var scale = Math.min( scale_x, scale_y );
      canvas.width = Math.round( size_x * scale );
      canvas.height = Math.round( size_y * scale );

      ctx.scale( scale, scale );
      ctx.lineWidth = 1.0 / scale;
      ctx.translate( - min_x, - min_y );

      var by_colors = {};
      for ( var i = 0; i < map.LINEDEFS.length; i++ )
      {
        var color = decide_line_color( map, i );
        if ( color == null )
          continue;
        if ( by_colors[color] == null )
          by_colors[color] = [];

        by_colors[color].push( i );
      }



      for ( var k in by_colors )
      {
        ctx.strokeStyle = k;
        ctx.beginPath();

        var lines = by_colors[k];
        for ( var i = 0; i < lines.length; i++ )
        {
          var line_id = lines[i];
          var linedef = map.LINEDEFS[line_id];

          var vertex_from = map.VERTEXES[linedef.from];
          var vertex_to = map.VERTEXES[linedef.to];

          ctx.moveTo(vertex_from.x, vertex_from.y);
          ctx.lineTo(vertex_to.x, vertex_to.y);
        }
        ctx.stroke();
        ctx.closePath();
      }

    } );
    </script>

    <p>But as beautiful as it may be, it does not use our tessellation algorithm.<br />
    Let's build those triangles !</p>

    <p>For that we need to build sets of segments, one set per sector. We must
    remember that segments actually have an order. We could iterate over
    each sector and then try to find its linedefs, but it would be inefficient (
    complexity in "number of linedefs" * "number of sectors").<br />
    We can do the opposite: iterate over each linedef and put it into the right bucket(s)
    (complexity in "number of lindefs").<br />
    Let's do that.
    </p>

<script class="visible_script">
function build_sectors_segments( map )
{
  var nb_sectors = map.SECTORS.length;
  var segments_per_sector = new Array( map.SECTORS.length );

  for ( var i = 0; i < nb_sectors; i++ )
    segments_per_sector[i] = [];

  for ( var i = 0; i < map.LINEDEFS.length; i++ )
  {
    var linedef = map.LINEDEFS[i];
    var A = map.VERTEXES[linedef.from];
    var B = map.VERTEXES[linedef.to];

    var right_side = map.SIDEDEFS[linedef.right];
    var left_side = null;
    if ( linedef.left != 0xFFFF )
      left_side = map.SIDEDEFS[linedef.left];

    if ( left_side == right_side )
      continue;

    segments_per_sector[right_side.sector].push( { A:A, B:B } );
    if ( left_side != null )
      segments_per_sector[left_side.sector].push( { A:B, B:A } );
  }

  return segments_per_sector;
}

function build_sectors_triangles( segments )
{
  // now, tessellation
  var tessellations = new Array( segments.length );
  for ( var i = 0; i < segments.length; i++ )
    tessellations[i] = tessellate( segments[i] );

  return tessellations;
}

function tessellate_map( map )
{
  map.tessellation = build_sectors_triangles( build_sectors_segments( map ) );
}
</script>

    <p>We can use that, and the sectors' lightlevels, to finally render a nicer map.<br />
    It will be the last example before the next chapter, where all of that will
    work together in a 3D view (but wait for the end of the chapter for that).</p>

    <div class="need_wad center">
      <button id="show_map_1-button">(Re)Play</button><br />
      <canvas width="512" height="512" id="show_map_1-canvas"></canvas>
    </div>

    <script>
    on_wad_loaded.push( function( wad ) {
      wad.images_manager = create_wad_images_manager( wad );
      var offscreen = document.createElement("canvas");
      offscreen.width = 64;
      offscreen.height = 64;
      var offscreen_ctx = offscreen.getContext("2d");
      offscreen_ctx.fillStyle = "red";
      offscreen_ctx.beginPath();
      offscreen_ctx.rect( 0, 0, 64, 64 );
      offscreen_ctx.fill();
      offscreen_ctx.closePath();

      var button = document.getElementById("show_map_1-button");
      var canvas = document.getElementById("show_map_1-canvas");
      var ctx = canvas.getContext("2d");
      ctx.fillStyle = "#f0f0f0";
      ctx.fillRect( 0, 0, canvas.width, canvas.height );
      ctx.imageSmoothingEnabled = false;

      DEBUG = ctx;

      var map_name = null;
      for ( var k in wad.maps ) { map_name = k; break; }

      var map = build_map( wad, map_name );

      var min_x;
      var min_y;
      var max_x;
      var max_y;

      min_x = max_x = map.VERTEXES[0].x;
      min_y = max_y = map.VERTEXES[0].y;
      for ( var i = 1; i < map.VERTEXES.length; i++ )
      {
        var vertex = map.VERTEXES[i];
        if ( vertex.x < min_x )
          min_x = vertex.x;
        else if ( vertex.x > max_x )
          max_x = vertex.x;

        if ( vertex.y < min_y )
          min_y = vertex.y;
        else if ( vertex.y > max_y )
          max_y = vertex.y;
      }

      var size_x = max_x - min_x;
      var size_y = max_y - min_y;

      var scale_x = canvas.width / (size_x*1.0);
      var scale_y = canvas.height / (size_y*1.0);

      var scale = Math.min( scale_x, scale_y );
      canvas.width = Math.round( size_x * scale );
      canvas.height = Math.round( size_y * scale );

      tessellate_map( map );

      var step_sector = 0;
      var step_triangle = 0;
      var sector_pattern = null;
      var interval_id = null;

      button.onclick = function()
      {
        if ( interval_id == null )
        {
          step_sector = 0;
          step_triangle = 0;
          sector_pattern = null;
          interval_id = window.setInterval( draw_next, 30 );
          button.textContent = "Stop";
          ctx.clearRect( min_x, min_y, size_x, size_y );
        }
        else
        {
          button.textContent = "Play";
          window.clearInterval( interval_id );
          interval_id = null;
        }
      }

      ctx.scale( scale, scale );
      ctx.lineWidth = 1.0 / scale;
      ctx.translate( - min_x, - min_y );

      var palettes = ensure_extracted( wad, wad.by_names["PLAYPAL"], extract_playpal );
      var colormap = ensure_extracted( wad, wad.by_names["COLORMAP"], extract_colormap );

      function draw_next( )
      {
        var triangle = null;

        while(triangle == null)
        {
          var triangles = map.tessellation[step_sector];
          if ( triangles == null )
          {
            if ( interval_id )
            {
              window.clearInterval( interval_id );
              interval_id = null;
              button.textContent = "Play";
            }
            return;
          }

          triangle = triangles[step_triangle];
          if ( triangle == null )
          {
            step_sector += 1;
            step_triangle = 0;
            sector_pattern = null;
          }
          else
            step_triangle += 1;
        }

        if ( sector_pattern == null )
        {
          var sector = map.SECTORS[step_sector];
          var pixmap = wad.images_manager( { type:'F', name: sector.floor_flat } );
          var imageData = pixmap.to_imageData(
            palettes[0], colormap[(255-sector.lightlevel) >> 3] );
          offscreen_ctx.putImageData( imageData, 0, 0 );

          sector_pattern = ctx.createPattern( offscreen, "repeat" );
          ctx.fillStyle = sector_pattern;
          ctx.strokeStyle = sector_pattern;
        }

        ctx.beginPath();
        ctx.moveTo( triangle.A.x, triangle.A.y );
        ctx.lineTo( triangle.B.x, triangle.B.y );
        ctx.lineTo( triangle.C.x, triangle.C.y );
        ctx.lineTo( triangle.A.x, triangle.A.y );
        ctx.stroke();
        ctx.fill();
        ctx.closePath();
      }
    } );
    </script>

    <p>It wad a long way to arrive here. But don't worry, we are not halfway
    to the destination I want to go :)</p>


    <h2>3D rendering - WebGL</h2>

    <disclaimer>
    Initialy the third chapter's title was only "3D rendering". After writing
    the WebGL part it was already so long and so off-topic with Doom that I decided
    to put it in its own chapter.<br />
    But it comes with a good news: if you don't care about WebGL, if you already
    have a library that handle all the small details for you, you can jump right
    to the next chapter. I even wrote a header at the beginning of this next chapter
    that summerizes everything this one contains, so you should be able to continue just fine.<br />
    <br />
    One more and last thing: the chapter you are now going to read could have been
    shorter. You could just get the "true color" version of every image
    used in Doom and, from there, it would be pretty quick. You would
    even get filtering and as much shades for each color as your screen can display.<br />
    The reason I didn't go that way is because I don't like the effect it produces.<br />
    Even in low light levels you can easily distinguish where the ennemies are
    and what they are doing. Everything becomes dull and flat, in my opinion.
    </disclaimer>

    <p>We managed to extract the textures and to tessellate the flats, and
    finding the shapes of the walls won't be hard.</p>

    <p>Yet, it requires two additional chapters chapters to cover this, so: why ? Here is a "short"
    answer:</p>

    <ul>
      <li>WebGL doesn't allow for "just rendering" something.
      To render something with webGL you need to use buffers and shaders.
      There is no "glBegin/glEnd" that would allow a quick prototyping
      before unpacking the big guns.</li>
      <li>Doom uses "real 3D" elements (flats ands walls) and sprites.
      Those two things aren't rendering the same way, even though they share
      some common properties.</li>
      <li>With "real 3D" elements and sprites, Doom also renders
      a sky, but it's not a skybox in a classical definition of the term.<br />
      It's not something infinitely far, it can (and it does, even in E1M1)
      obfuscate parts of the level.</li>
      <li>Walls, flats and sprites can move. We can't just put them
      in a buffer and proceed, we need an editable buffer with a smart access.</li>
      <li>Rendering everything at once is doable but a bit stupid. Doom is a
      "closed-world" (by opposition to "open-world") meaning that by default the
      player cannot be anywhere, and then the map excavates areas where the player can be.<br />
      Optimizations can be done on such a structure, that couldn't be done in an open world.<br />
      We will use that.</li>
    </ul>

    <p>It's not going to be a bit long, it's going to take forever and half.<br />
    But we will go through that, step by step, especially for the parts that
    aren't already covered everywhere on the web.<br />
    By that I mean that I'll not explain every tiny details of the WebGL part,
    for which you have a massive amount of tutorials available online, and I'll focus
    on what we will do with it.</p>

    <p>It'll be especially hard for me, as, unlike for 2D contexts I was using until now,
    I cannot have as many 3D contexts as I want. You don't care (and why would you),
    but I needed to mention that.</p>

    <p>But enough talking, let's begin this journey.</p>

    <p>To use WebGL, you need a &lt;canvas&gt;. Once you have it, you call
    it's method "getContext", to which you pass either "webgl" or "webgl2", depending
    on what you want. <br />
    Altough webgl would make this available to as many people as possible,
    I decided to use webgl2.<br />
    Those things are what is missing in webgl1 and motivated my choice:</p>

    <ul>
      <li>Integers attributes, even shorts attributes.</li>
      <li>Integers textures.</li>
      <li>Copy from texture to texture.</li>
      <li>Copy buffer to buffer.</li>
      <li>Retrieve data from buffer.</li>
      <li>texelFetch</li>
      <li>querying texture size in the shader</li>
    </ul>

    <p>
    But I started to write this document with webgl1 in mind, so this
    change will likely introduce typos I'll have to fix.
    </p>

    <p>Let's start with what will be the basis of our rendering.</p>

<script class="visible_script">
function create_doom_rendering( canvas )
{
  var res = {};

  res.ctx = canvas.getContext("webgl2");

  return res;
}
</script>

    <p>We will need shaders. I'll not give their code yet, but let's explain
    how they will work. Each decision is more or less arbitrary and there are
    tons of other ways of doing it.</p>

    <ul>
      <li>Positions will be in pixels, like in Doom. We will send positions
      directly, without rescaling.</li>
      <li>Texture coordinates will also be in pixels. It won't be floats going from
      0 to 1 but shorts.</li>
      <li>We will use three rendering pass: one for the walls+flats, one for the sky and
      one for the sprites.</li>
      <li>We will use textures atlases. Three of them, one for each pass as they
      won't share images (a sprite is never displayed on a wall, a flat is never used
      as a sprite, the sky texture is only used for sky etc).</li>
      <li>We will send textures as they are stored in the opt_pixmap. The shader
      will have the colormap and the palettes and will be responsible of
      transforming the indexes into colors.</li>
      <li>Finally, we will also provide informations on sectors to the shaders.
      Not everything, but the lightlevel and the effect, if applicable (for
      flickering light).</li>
      <li>The passes will have different vertex shader, but the same
      fragment shader. It means that we will enable the lightning on sprites
      by indicating to the shader the sector the sprite is in.</li>
      <li>Because WebGL defaults on facing a negative Z with an Y up, we cannot
      map doom-x to WebGL-x and doom-y to WebGL-y. I could use a custom transformation
      matrix for the camera, but I could also remap doom-x to WebGL-z and doom-y to WebGL-x.<br />
      We will study that.</li>
      <li>The camera location and rotation will use real numbers. The result
      would look shaky otherwise (I think). The camera location will be in world's
      coordinates. The camera rotation will be three angles, applied in the order<br />
      yaw(put a finger on top of your head, and rotate around that axis)-><br />
      pitch(then put a finger in your left ear, and rotate around that axis)-><br />
      roll(then put a finger on top of your nose, and rotate around that axis).</li>
      <li>Light, both the basic level and the effects, will be done GPU side (by the shader).
      That way, we won't have to update our textures all the time.</li>
    </ul>

    <p>Please also note the following:</p>

    <ul>
      <li>Doom includes animated textures (like water). We won't handle them for now.</li>
      <li>Doom includes sliding textures. Same as above, it won't be covered now (and in
      that case maybe never).</li>
      <li>We can easily retrieve the starting position of the player (the THING with a type=1),
      but we cannot easily detect the sector this starting position belongs to.<br />
      We will do that, but it will be in the next chapter.</li>
    </ul>

    <p>In addition to the atlas itself, we will provide meta-data about sectors and the
    layout of the atlas. What we would do on a standard CPU is to use arrays, but
    arrays in GLSL require their size to bo known when the shader is compiled.</p>

    <p>Instead, we will use textures that we will be arrays in disguise. I call them gpu-array.<br />
    In their simplest form, each column of the texture will be an entry in the array, the lines
    being used to store the values. But this would lead to a very thin and very long texture,
    and this very long side may exceed quickly what webGL allows for the dimensions of a
    texture. The texture wouldn't be too big, only one of its side would be.</p>

    <p>We will use a slightly more complicated version of the above: the texture will
    have a fixed width, and if the index exceeds this width, it will loop
    on the next line. More concisely and clearly put:</p>

    <pre>
x = index % texture_width;
y = (index / texture_width) * (number_of_lines_per_entry);
    </pre>

    <p>should do it.</p>


    <h3>The textures</h3>
    <p>We will use several textures, so here is a table describing them:</p>

    <table>
      <tr>
        <td>Name</td>
        <td>Entry type</td>
        <td>GL type</td>
        <td>Red</td>
        <td>Green</td>
        <td>Blue</td>
        <td>Alpha</td>
        <td>Description</td>
      </tr>

      <tr>
        <td>u_atlas</td>
        <td>opt pixel</td>
        <td>RG8UI / RG_INTEGER / UNSIGNED_BYTE</td>
        <td>The index</td>
        <td>The transparency. If 1, the pixel is opaque. Otherwise the pixel is transparent.</td>
        <td>-</td>
        <td>-</td>
        <td>Contains the pixels of the atlas, i.e. the pixels of all the images of the atlas.</td>
      </tr>


      <tr>
        <td>u_atlas_layout</td>
        <td>rectangle</td>
        <td>RGBA16UI / RGBA_INTEGER / UNSIGNED_SHORT</td>
        <td>x</td>
        <td>y</td>
        <td>width</td>
        <td>height</td>
        <td>Contains the rectangles of each sub-texture inside the atlas.</td>
      </tr>

      <tr>
        <td>u_playpal</td>
        <td>colors</td>
        <td>RGB8 / RGB / UNSIGNED_BYTE</td>
        <td>Red</td>
        <td>Green</td>
        <td>Blue</td>
        <td>-</td>
        <td>Contains the PLAYPAL lump.</td>
      </tr>

      <tr>
        <td>u_colormap</td>
        <td>indexes</td>
        <td>R8UI / RED_INTEGER / UNSIGNED_BYTE</td>
        <td>The index</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>Contains the COLORMAP lump.</td>
      </tr>

      <tr>
        <td>u_sectors</td>
        <td>sectors meta-data</td>
        <td>RGB8UI / RGB_INTEGER / UNSIGNED_BYTE</td>
        <td>The light level of the sector.</td>
        <td>The special of the sector.</td>
        <td>The lowest light level of the adjacent sectors, or 0 if there
        is no such sector.</td>
        <td>-</td>
        <td>Contains needed informations to apply flickering/glowing light effects</td>
      </tr>
    </table>

    <p>"u_atlas", "u_playpal" and "u_colormap" will be used by the fragment shader.<br />
    "u_atlas_layout" and "u_sectors" will be used by the vertex shader, that will
    unpack the data and pass them to the fragment shader via varyings (without the
    "varying" keyword, because WebGL2).</p>

    <p>All of those texture will work with a "nearest" filter for the min and mag field:
    we are dealing with indexes, not true color. Blending indexes does not produce a meaningful
    result. In the same way, blending layouts, or sector information etc, don't produce a nice result.</p>

    <p>All of those textures will clamp to the edge. We will use an atlas to hold textures,
    so we won't be able to auto-repeat textures "for free" anyway, and clamping to edge
    allows us to use non-power-of-two textures.</p>

    <h3>The vertices</h3>
    <p>Each vertex will be packed like this:</p>

    <table>
      <tr>
        <td>Name</td><td>Type</td><td>Description</td>
      </tr>

      <tr>
        <td>x</td><td>short</td><td rowspan="3">The position of the vertex</td>
      </tr>

      <tr>
        <td>y</td><td>short</td>
      </tr>

      <tr>
        <td>z</td><td>short</td>
      </tr>

      <tr>
        <td>tx</td><td>short</td><td rowspan="2">The position in the texture</td>
      </tr>

      <tr>
        <td>ty</td><td>short</td>
      </tr>

      <tr>
        <td>sector</td><td>ushort</td><td>An index in the gpu-array "a_sectors"</td>
      </tr>

      <tr>
        <td>texture</td><td>ushort</td><td>An index in the gpu-array "a_atlas_layout"</td>
      </tr>
    </table>

    <h3>The shaders' codes (simplified)</h3>

    <p>Based on what we declared, we can write the code of our shader.</p>
    <p>The code below is not the final code for the shader, as it doesn't include
    the special treatment for the sky. It does, however, implement the basics we will
    use.</p>

    <p>As the vertex shader is applied first, it's also the first we will look at:</p>
    <pre class="glsl_script" id="vertex_source-simplified">
/*
  Those four lines are there because WebGL is what it is. Without those lines,
  the shader would be interpreted as a WebGL1 shader, because seemingly requesting a WebGL-&gt;2&lt;-
  context wasn't explicit enough that we have to repeat that in the shader itself.
*/
#version 300 es
precision lowp int;
precision lowp float;
precision lowp isampler2D;

/* Now we will have three blocks: the uniforms, the attributes and the varyings. */
/* I decided to prefix every uniform with a "u_", every attribute with a "a_" and
   every varying with a "v_". */

/* Uniforms act like global constants, as they don't vary for a given rendering pass.
   Here, we have three uniforms, which are the camera (the projection matrix),
   the gpu-array which contains the layout of the atlas, and the gpu-array
   containing the informations of the sectors. */
uniform mat4 u_camera;
uniform isampler2D u_atlas_layout;
uniform isampler2D u_sectors;

/* Attributes are per-vertex informations. We have four of them, already described above. */
in ivec3 a_position;
in ivec2 a_texcoord;
in uint a_sector;
in uint a_texture;

/* Varyings are what goes from the vertex shader to the fragment shader.
   By default, each vertex yield a value for each attribute, and the GPU
   interpolate those values before passing them to the fragment shader.
   But you can only interpolate continuous values. For discrete values,
   one vertex (called the "provoking vertex", if you encounter that term
   in the OpenGL specification, you'll know what it means) decides the value,
   that is copied as is to each fragment. But GLSL imposes to repeat this
   by adding the "flat" keyword to every non-interpolated varyings.
   Moreover, the understandable keyword "varying" has been removed and replaced
   by the obscure keyword "out", preventing you from using the same code
   for both steps. */
flat out ivec4 v_texture_area;
out vec2 v_texcoord;
flat out int v_colormap;

/*
  Each step has to declare a main, which takes no attribute and returns void.
  If you think it's stupid and that we should just be allowed to write the body
  directly, outside of any boilerplate code, I agree with you.
*/
void main()
{
  /*
    The vertex step has to put a value inside a variable automagically
    declared: "gl_Position". Why not imposing a main with "out" parameters
    instead of this global-variable approach ? I don't know.
  */
  gl_Position = u_camera * vec4( vec3(a_position), 1.0 );

  /*
    Now, we declared three varyings, so we have to assign values to them.
    The threee blocks below do that. */
  v_texcoord = vec2( a_texcoord );

  uvec2 layout_size = uvec2(textureSize( u_atlas_layout, 0));
  ivec2 layout_coord = ivec2(
    a_texture % layout_size.x,
    a_texture / layout_size.x );
  v_texture_area = texelFetch( u_atlas_layout, layout_coord, 0 );

  uvec2 sectors_size = uvec2(textureSize( u_sectors, 0 ));
  ivec2 sector_coord = ivec2(
    a_sector % sectors_size.x,
    a_sector / sectors_size.x );
  ivec3 sector = texelFetch( u_sectors, sector_coord, 0 ).rgb;
  v_colormap = (255 - sector.r)/8;
}
</pre>


  <p>To work with the vertex shader, we need a fragment shader:</p>
<pre class="glsl_script" id="fragment_source-simplified">
#version 300 es
precision lowp int;
precision lowp float;
precision lowp isampler2D;

/* A fragment shader has access to uniforms and varyings. There is
no equivalent of the "attributes" for the fragment shader.
Like before, I decided to prefix all uniforms with "u_". The names of the
varyings are imposed by the vertex shader.
The fragment shader does the color resolution. Remember that a texture is
made of indexes that are remapped to darker tones by the COLORMAP before
being turned into true colors by the PLAYPAL. Playpals have different tints:
more reddish playpal will be used when you take damage, and more yellowish
playpals will be used when you take items.
*/
uniform isampler2D u_atlas;
uniform isampler2D u_colormap;
uniform sampler2D u_playpal;
uniform int u_used_playpal;

in vec2 v_texcoord;
flat in ivec4 v_texture_area;
flat in int v_colormap;

/*
  More stupid GLSL stuff. In previous versions of GLSL you had to assign
  an automagically declared variable, called "gl_FragColor". It was as obscure
  as the gl_Position for the vertex shader, but it was coherent.
  In newer versions, this variable no longer exists (but you cannot reuse its name).
  Instead, you have to declare an out variable with the right type and whatever
  name you want.
*/
out vec4 o_FragColor;

/*
  What "-2 mod 5" evals to ? In mathematics (as in your calculator and in Excel)
  is evals to 3. It evals to the smallest positive value such as blablabla.
  Not in GLSL. In GLSL, the behavior is undefined:
  "Results are undefined if one or both operands are negative."
  So, I should NOT define the function below as I did.
  I took the assumption that it should returns either "-2" or "3".
  If it's the case, the formula below ensures it will be "3".
  */
ivec2 my_mod( ivec2 x, ivec2 y )
{
  return (((x%y)+y)%y);
}

void main()
{
  ivec2 texcoord = ivec2( v_texcoord );
  texcoord = my_mod(texcoord, v_texture_area.zw);
  texcoord = texcoord + v_texture_area.xy;

  ivec2 pixel = texelFetch( u_atlas, texcoord, 0 ).rg;
  /* We use an "opt_pixmap": each pixel must have its second byte set
  to "1" to exists.*/
  if ( pixel.g != 1 )
    discard;

  int index = pixel.r;
  int reindex = texelFetch( u_colormap, ivec2( index, v_colormap ), 0 ).r;
  vec4 color = texelFetch( u_playpal, ivec2( reindex, u_used_playpal ), 0 );

  o_FragColor = vec4( color.rgb, 1);
}
</pre>

    <p>We will see a modified version of this shader later, but I wanted to
    have it so I could display examples. And it's exactly what we will do right now.</p>

    <h3>In one go</h3>

    <p>In the next part we will create tools to allow us a higher access to the data.
    However, after I wrote that chapter I felt like it was a very long and uninteresting
    one, that we didn't know where we were going and that there was no example.</p>

    <p>So I added this part. The goal here is to have a working sample, something
    static, simple, with hard coded values if needed, but <strong>something</strong> at least.</p>

    <p>Below is a huge block of code, heavily commented. And below that is a button that
    opens a pop-up running that example. I believe that most computer scientist here will
    be more comfortable with that approach, were we will build abstraction from a working
    concrete example.</p>

    <p>But in any case, it's a long run. The goal is to display a six-sided box,
    each side displaying an image, with a camera rotating around the box.</p>

    <p>I voluntarily skipped most if not all security tests, to improve readibility.
    How to add those tests is heavily language-specific anyway.</p>

<script class="visible_script">
function in_one_go_1( wad, canvas, images_access )
{
  // the starting point of all things: a gl context.
  var gl = canvas.getContext("webgl2");

  /************************************************************/
  /************************** SHADER **************************/
  /************************************************************/

  /* In OpenGL, each step is called "shader", and the actual shader
  is called "program". Moreover, you don't bind a shader to a target
  to access it, you use it directly. Yep, absolutly inconsistent.
  And WebGL uniformize this a bit, as every resource is created with "createXXX",
  but in OpenGL you create textures with "genTextures" and you create shaders
  with "createShader". And it goes on and on, like this part of the API has nothing
  in common with the rest of it.
  */
  var vertex_step = gl.createShader();
  var vertex_step_source = document.getElementById("vertex_source-simplified").innerText;
  gl.shaderSource(vertex_step, vertex_step_source);
  gl.compileShader(vertex_step);

  var fragment_step = gl.createShader();
  var fragment_step_source = document.getElementById("fragment_source-simplified").innerText;
  gl.shaderSource(fragment_step, fragment_step_source);
  gl.compileShader(fragment_step);


  var shader = gl.createProgram();
  gl.attachShader(shader, vertex_step);
  gl.attachShader(shader, fragment_step);
  gl.linkProgram(shader);


  /************************************************************/
  /*************************** MESH ***************************/
  /************************************************************/

  /* We will have to create 6 faces. With 2 triangles per face,
  3 points per triangle, and 3 coordinates+2 texture coordinates+the sector+the texture,
  it's 6*2*3*(3+2+1+1) = 36*7 = 252 elements we will have to set.
  Setting them one by one would be pretty long, and as it's just for a working
  example it's something I would rather not do.*/
  /*Instead, we can have a function that write a point in a buffer (7 steps) +
  a function that write a triangle in a buffer (3 steps) + a function
  that write a quad in a buffer (2 step) + a function that write a cube in a buffer
  (6 step).*/

  function draw_point( b, pos, p )
  {
    b.setInt16 ( pos.v, p.x );        pos.v += 2;
    b.setInt16 ( pos.v, p.y );        pos.v += 2;
    b.setInt16 ( pos.v, p.z );        pos.v += 2;
    b.setInt16 ( pos.v, p.tx );       pos.v += 2;
    b.setInt16 ( pos.v, p.ty );       pos.v += 2;
    b.setUint16( pos.v, p.sector );   pos.v += 2;
    b.setUint16( pos.v, p.texture );  pos.v += 2;
  }

  function draw_triangle( b, pos, t )
  {
    t.A.sector =
    t.B.sector =
    t.C.sector = t.sector;

    t.A.texture =
    t.B.texture =
    t.C.texture = t.texture;

    draw_point( b, pos, t.A );
    draw_point( b, pos, t.B );
    draw_point( b, pos, t.C );
  }

  function draw_quad( b, pos, A, B, C, D, sector, texture )
  {
    A.tx =  0; A.ty =  0;
    B.tx = 64; B.ty =  0;
    C.tx = 64; C.ty = 64;
    D.tx =  0; D.ty = 64;

    draw_quad( b, pos, { A:A, B:B, C:C, sector:sector, texture:texture } );
    draw_quad( b, pos, { A:A, B:C, C:D, sector:sector, texture:texture } );
  }

  function draw_cube( b, pos, sectors, textures )
  {
  /*
    Up: positive y
    Far: negative z
    Right: positive x

        E---------H
       /|        /|
      / |       / |
     /  |      /  |
    A---------D   |
    |   |     |   |
    |   F-----|---G
    |  /      |  /
    | /       | /
    |/        |/
    B---------C
  */


    var s = 1;
    var A = { x:-s, y:+s, z:+s };
    var B = { x:-s, y:-s, z:+s };
    var C = { x:+s, y:-s, z:+s };
    var D = { x:+s, y:+s, z:+s };
    var E = { x:-s, y:+s, z:-s };
    var F = { x:-s, y:-s, z:-s };
    var G = { x:+s, y:-s, z:-s };
    var H = { x:+s, y:+s, z:-s };

    draw_quad( b, pos, A, B, C, D, sectors[0], textures[0] ); // front
    draw_quad( b, pos, D, C, G, H, sectors[1], textures[1] ); // right
    draw_quad( b, pos, H, G, F, E, sectors[2], textures[2] ); // back
    draw_quad( b, pos, E, F, B, A, sectors[3], textures[3] ); // left
    draw_quad( b, pos, E, A, D, H, sectors[4], textures[4] ); // top
    draw_quad( b, pos, B, F, G, C, sectors[5], textures[5] ); // bottom
  }

  var vertexes = new Int16Array( 6*2*3*(3+2+1+1) );
  var view = new DataView( vertexes );
  var pos = { v:0 };

  draw_cube( view, pos, [ 0, 1, 2, 3, 4, 5 ], [ 0, 1, 2, 3, 4, 5 ] );

  /* setting up buffer GPU-side. */
  /* as we already have all the data CPU side, we can send them at initialization */
  var buffer = gl.createBuffer();
  gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
  gl.bufferData( gl.ARRAY_BUFFER, vertexes, gl.STATIC_DRAW );

  /************************************************************/
  /************************** ATLAS ***************************/
  /************************************************************/

  /* building an altas of images */
  /* first, we select some image. Which one is arbitrary */
  var images = [
    images_access( { type: 'F', name: 'FLOOR4_8' } ),
    images_access( { type: 'F', name: 'GATE1' } ),
    images_access( { type: 'T', name: 'DOOR3' } ),
    images_access( { type: 'S', name: 'TROOA1' } ),
    images_access( { type: 'T', name: 'BRNSMAL1' } ),
    images_access( { type: 'F', name: 'FLAT1' } )
  ];

  /* because we have a small number of images, we can store all of them on a single "line".
  Tha atlas' texture won't be too large (hopefully).*/
  /* we still need to determine the size of the atlas, though, as well as the location
  of each image in the atlas */
  var total_width = 0;
  var max_height = 0;
  var rectangles = [];
  for ( var i = 0; i < images.length; i++ )
  {
    rectangles.push( total_width ); // x
    rectangles.push( 0 );           // y
    rectangles.push( images[i].w ); // w
    rectangles.push( images[i].h ); // h
    total_width += images[i].w;
    max_height = Math.max( max_height, images[i].h );
  }

  var atlas_layout = gl.createTexture();
  gl.bindTexture( gl.TEXTURE_2D, atlas_layout );
  /* We are dealing with gpu-array in disguise, we don't want interpolation
  between adjacent cells. Same applies for indexes (don't blend them),
  or even the palette. The palette is made of colors, but the organization
  of the colors inside it are arbitrary and, therefore, you don't want
  to blend them. */
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  /* Those lines are necessary to have non-power-of-two textures in WebGL.
  The default is repeat, and doesn't allow you to have those. */
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
  gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA16UI,
  images.length, // w
  1, // h
  0, gl.RGBA_INTEGER, gl.UNSIGNED_SHORT,
  new Uint16Array( rectangles ) );


  var atlas = gl.createTexture();
  gl.bindTexture( gl.TEXTURE_2D, atlas );
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );

  /* We define a texture but not its pixels yet. It's because we don't have ONE big
  image containing all of our small images. We will send them one by one. */
  gl.texImage2D( gl.TEXTURE_2D, 0, gl.RG8UI, total_width, max_height, 0, gl.RG_INTEGER, gl.UNSIGNED_BYTE, null );
  for ( var i = 0; i < images.length; i++ )
  {
    gl.texSubImage2D( gl.TEXTURE_2D, 0,
      x, y,
      opt_pixmap.w, opt_pixmap.h,
      gl.RG_INTEGER, gl.UNSIGNED_BYTE,
      new Uint8Array( opt_pixmap.buf.buffer ) );
  }


  /* the colormap and the playpal are directly taken from the binary
  data of the wad. It doesn't save us the trouble of creating and setting
  up the textures, though */
  /* some black magic to obtain a subpart of an array. Would be easier in C ... */
  function wad_sub_buffer( wad, lump_name )
  {
    var lump = wad.by_names[lump_name];
    return wad.buffer.slice(
    lump.offset,
    lump.offset + lump.size);
  }

  var colormap = gl.createTexture();
  gl.bindTexture( gl.TEXTURE_2D, colormap );
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
  gl.texImage2D( gl.TEXTURE_2D, 0, gl.R8UI,
  256, 34, // imposed by the wad format
  0, gl.RED_INTEGER, gl.UNSIGNED_BYTE, new Uint8Array( wad_sub_buffer( wad, "COLORMAP" ) ) );

  var playpal = gl.createTexture();
  gl.bindTexture( gl.TEXTURE_2D, playpal );
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
  gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB8,
  256, 14, // imposed by the wad format
  0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array( wad_sub_buffer( wad, "PLAYPAL" ) ) );

  /* finally (for the textures) we need a mock-up for the sectors. We only need 6 sectors,
  and because we are testing stuff, it would be good to use those 6 slots
  to actually cover some cases: a brightly lighted sector, a dark sector,
  a blinking sector, a oscillating light sector ... and that's it, bright sectors
  for the others */

  /* remember that each entry has three values: the lightlevel of the sector,
  the special of the sector and the lowest lightlevel of any adjacent sector */
  var cpu_sectors = [];
  cpu_sectors.push( 255 ); cpu_sectors.push( 0 ); cpu_sectors.push( 255 );
  cpu_sectors.push(  64 ); cpu_sectors.push( 0 ); cpu_sectors.push( 255 );
  cpu_sectors.push( 255 ); cpu_sectors.push( 1 ); cpu_sectors.push(  64 );
  cpu_sectors.push( 255 ); cpu_sectors.push( 8 ); cpu_sectors.push(  64 );
  cpu_sectors.push( 255 ); cpu_sectors.push( 0 ); cpu_sectors.push( 255 );
  cpu_sectors.push( 255 ); cpu_sectors.push( 0 ); cpu_sectors.push( 255 );

  var sectors = gl.createTexture();
  gl.bindTexture( gl.TEXTURE_2D, playpal );
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
  gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB8UI,
  6, 1,
  0, gl.RGB_INTEGER, gl.UNSIGNED_BYTE, new Uint8Array( cpu_sectors );

  /* We need a camera. */

}


</script>



    <h3>The tools</h3>

    <p>We will manipulate textures and buffers. Unlike arrays in Javascript, WebGL buffers
    and textures don't automatically increase their size when they are full.</p>

    <p>It's something we will have to do ourselfs, and to avoid a quadratic complexity we
    will increase those size not by 1, but by a fraction of the present size.</p>

    <p>The formula I'll use all the time is this one:</p>

    <pre>
      while old_size &lt; new_size do
        old_size := floor(old_size * 1.3) + 1
    </pre>

    <p>
      It's not as efficient as it could be, we don't NEED a loop here. But I think
      it's absolutly non-interesting, so let's move on.<br />
      The "* 1.3" part is there to ensure the "fraction of the present size". The "+1" is to avoid
      rounding issues with small values, where "floor(old_size * 1.3)" would actually yield
      old_size itself.
    </p>

    <p>Resizing something will be done with the following steps:</p>

    <pre>
      Based on the old size "N1", calculate the new size "N2"
      Allocate a new container of size "N2".
      Copy N1 items from the old container to the new container.
      If possible, deallocate the old container
    </pre>

    <p>Nothing very hard to understand, but WebGL being what it is, it will be
    a long road.</p>

    <p>So, what kind of tool do we need ?</p>

    <ul>
      <li>We need a tool to allocate and resize textures.</li>
      <li>We need a tool to allocate and resize buffers.</li>
      <li>We need a tool to allocate and resize javascript buffers. Yeah :/</li>
      <li>We need an atlas, and its layout.</li>
      <li>We need a smart access to the buffer, to remove and add primitives quickly.</li>
      <li>We need a camera.</li>
    </ul>

    <p>We will need a toolbox to contain some of those tools, so let's do that:</p>

<script class="visible_script">
function create_gl_toolbox( gl )
{
  var res = {};

  res.gl = gl;

  return res;
}
</script>

    <p>This function takes a gl context, which somehow ties it to a specific canvas.</p>

    <p>This toolbox will have to create textures. This function will not be used directly,
    but will serve as a premiss to higher level creation functions. Note that as the
    function ends, the texture remains bound.</p>
<script class="visible_script">
function gl_toolbox_create_texture( toolbox )
{
  var res = {};

  var gl = toolbox.gl;

  res = { id: gl.createTexture() };
  gl.bindTexture( gl.TEXTURE_2D, res.id );
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );

  return res;
}
</script>

    <p>This creates a texture, but does not add data to it, not even its size.<br />
    Even though OpenGL tends to have several functions call to perform a single action,
    the definition of the size, the internal representation of the data, the
    data format that will be available in the shader, the type of each pixel cpu-side and
    the actual pixels of a texture are all sent at the same time.</p>

    <p>We want to keep those informations (except the pixels) with the texture,
    so we can recreate bigger version of it later. The function below does that:</p>

<script class="visible_script">
function gl_toolbox_define_texture_data(
  toolbox,
  texture,
  width, height,
  internalFormat, format, type,
  pixels )
{
  var gl = toolbox.gl;

  texture.w        = width;
  texture.h        = height;
  texture.internal = internalFormat;
  texture.format   = format;
  texture.type     = type;

  gl.texImage2D( gl.TEXTURE_2D, 0, texture.internal,
  texture.w, texture.h, 0,
  texture.format, texture.type, pixels );
}
</script>

    <p>And this function groups the two previous ones:</p>

<script class="visible_script">
function gl_toolbox_create_texture_with_data(
  toolbox,
  width, height,
  internalFormat, format, type,
  pixels )
{
  var res = gl_toolbox_create_texture( toolbox );
  gl_toolbox_define_texture_data( toolbox, res, width, height, internalFormat, format, type, pixels );
  return res;
}
</script>

    <p>With that, most texture creation turns into a single line (expanded a bit more than
    that, for clarity). If you have doubts about the code, please go back to the previous table above.</p>

<script class="visible_script">
function gl_toolbox_create_atlas( toolbox, w, h )
{
  var gl = toolbox.gl;
  return gl_toolbox_create_texture_with_data(
    toolbox,
    w, h,
    gl.RG8UI, gl.RG_INTEGER, gl.UNSIGNED_BYTE,
    null );
}

function gl_toolbox_create_atlas_layout( toolbox, nb_entries )
{
  var w = 64;
  var h = Math.ceil( nb_entries / (w*1.0) );

  var gl = toolbox.gl;
  return gl_toolbox_create_texture_with_data(
    toolbox,
    w, h,
    gl.RGBA16UI, gl.RGBA_INTEGER, gl.UNSIGNED_SHORT,
    null );
}

function gl_toolbox_create_playpal( toolbox, playpal )
{
  var gl = toolbox.gl;
  return gl_toolbox_create_texture_with_data(
    toolbox,
    256, 14,
    gl.RGB8, gl.RGB, gl.UNSIGNED_BYTE,
    new Uint8Array( playpal ) );
}

function gl_toolbox_create_colormap( toolbox, colormap )
{
  var gl = toolbox.gl;
  return gl_toolbox_create_texture_with_data(
    toolbox,
    256, 34,
    gl.R8UI, gl.RED_INTEGER, gl.UNSIGNED_BYTE,
    new Uint8Array( colormap ) );
}
</script>

    <p>The creation of an Uint8Array over an ArrayBuffer don't copy the underlying buffer,
    it just wraps it. The WebGL API requires this wrapping (it failed when I tried with
    a raw ArrayBuffer).</p>

    <p>The next (and last) function, the one creating the texture in charge of sectors,
    is a bit different. It's different because this time the information is not directly
    there, we must compute it first.</p>

    <p>So, what is this information ? Well, for each sector we need: its lightlevel (present
    explicitely, good), its special (also there explicitely, so far so good), and the lowest
    lightlevel among adjacent sectors. This last one isn't there, we must find it.</p>

    <p>How can we do that ? We can iterate over each double-sided linedef, and cross assign
    lightlevel for the two adjacent sectors of this linedef. However, if a sector has no
    adjacent sector, this value we are looking for, should be zero for that sector.</p>

    <p>Zero is not a good initialization for our "min-finding" loop. We will need an explicit
    boolean array, as big as the number of sectors.</p>

    <p>But we can hijack the field "special" for the duration of the "min-finding" operation,
    and turn it into this boolean array.</p>

    <p>Ok, let's implement that: (this function supposes that the map has already been extracted)</p>

<script class="visible_script">
function gl_toolbox_create_sectors( toolbox, map )
{
  var SECTORS = map.SECTORS;
  var LINEDEFS = map.LINEDEFS;
  var SIDEDEFS = map.SIDEDEFS;

  var w = 64; // arbitrary
  var h = Math.ceil( SECTORS.length / (w*1.0) );

  var NO_ADJACENT_SECTOR_YET = 0;
  var HAS_ADJACENT_SECTOR = 1;


  var array = new Uint8Array( w*h*3 );
  for ( var i = 0; i < SECTORS.length; i++ )
  {
    array[i*3] = SECTORS[i].lightlevel;
    array[i*3+1] = NO_ADJACENT_SECTOR_YET; // not seen yet
    array[i*3+2] = 255; // maximum value (so we can "min" it with adjacent sectors)
  }

  for ( var i = 0; i < LINEDEFS.length; i++ )
  {
    var line = LINEDEFS[i];
    if ( line.left == 0xffff )
      continue;

    var right_id = SIDEDEFS[line.right].sector;
    var left_id = SIDEDEFS[line.left].sector;

    if ( right_id == left_id ) // same sectors on both side: doesn't count
      continue;

    var sector_right = SECTORS[right_id];
    var sector_left = SECTORS[left_id];

    array[right_id*3+2] = Math.min( array[right_id*3+2], array[left_id*3] );
    array[left_id*3+2] = Math.min( array[left_id*3+2], array[right_id*3] );

    array[right_id*3+1] = HAS_ADJACENT_SECTOR; // seen !
    array[left_id*3+1] = HAS_ADJACENT_SECTOR; // seen !
  }

  for ( var i = 0; i < SECTORS.length; i++ )
  {
    var sector = SECTORS[i];
    if ( array[i*3+1] == NO_ADJACENT_SECTOR_YET ) // not seen
      array[i*3+2] = 0; // no adjacent sector => 0

    array[i*3+1] = sector.special; // field goes to its final usage: holding the "special"
  }

  var gl = toolbox.gl;
  return gl_toolbox_create_texture_with_data(
    toolbox,
    w, h,
    gl.RGB8UI, gl.RGB_INTEGER, gl.UNSIGNED_BYTE,
    array );
}
</script>

    <p>As said previously, we will need to resize some of those
    textures. Resizing will be done with two steps, the creation of a new, bigger, texture and
    then the copy of the old texture onto the new one. <br />
    Because now each texture is aware of its internal format, its format and its type,
    we can lay out the code of the creation of a new texture, based on an old one:
    </p>

<script class="visible_script">
function gl_toolbox_create_texture_of_different_size( toolbox, texture, new_w, new_h )
{
  var gl = toolbox.gl;
  return gl_toolbox_create_texture_with_data(
    toolbox,
    new_w, new_h,
    texture.internal, texture.format, texture.type,
    null );
}
</script>

  <p>The copy itself is harder. It's not inherently harder, it is so because of the limitations
  of WebGL (1 &amp; 2 for that matter). In modern OpenGL we have a function
  called "glCopyImageSubData" that does exactly what we want, but it's not available here,
  so we will have to use WebGL black magic (in that case we will use the unholy
  book "De Framebuffer Mysterii").</p>

<script class="visible_script">
function gl_toolbox_copy_texture( toolbox, dst, src, rectangle )
{
  var gl = toolbox.gl;
  var r = rectangle; // shorten the name, for convenience

  if ( toolbox.fbos == null ) // we never used fbos, we need to create them
  {
    toolbox.fbos = {
      src: gl.createFramebuffer(),
      dst: gl.createFramebuffer()
    };
  }

  gl.bindFramebuffer(gl.READ_FRAMEBUFFER, toolbox.fbos.src);
  gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, src.id, 0);

  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, toolbox.fbos.dst);
  gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, dst.id, 0);
  gl.blitFramebuffer(
    0   , 0   , r.w - 1       , r.h - 1       ,
    r.x , r.y , r.x + r.w - 1 , r.y + r.h - 1 ,
    gl.COLOR_BUFFER_BIT, gl.NEAREST);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}
</script>

    <details>
      You may think that, instead of joking about WebGL, I should teach you what I am doing.
      I would agree, in general, but in that case I don't think so. First because there is plenty
      of tutorials online about OpenGL (and most of them will work verbatim with WebGL) and WebGL.
      You don't need me. The second reason is that I think that OpenGL is overly complicated.<br />
      There is nothing to <i>understand</i>, it's mostly trials and errors. It would take a very long
      post to pinpoint what is wrong with this API, but I think that its size and its leniency with
      errors are a good combination to ensure that you'll never be able to be sure that you are doing
      it the correct way, so you'll always find more pitfall traps and never master anything.
    </details>



    <p>Now that we can re-create a new, bigger, texture, and that we can copy a texture onto
    an other, we can implement the "increase the texture size" operation.<br />
    Please note that, like the "realloc()" in C, the function returns the new texture, it does not
    modify the existing one.</p>

<script class="visible_script">
function gl_toolbox_resize_texture( toolbox, texture, new_width, new_height )
{
  var res = gl_toolbox_create_texture_of_different_size( toolbox, texture, new_width, new_height );
  gl_toolbox_copy_texture( toolbox, res, texture, { x:0, y:0, w:texture.w, h:texture.h } );
  toolbox.gl.deleteTexture( texture.id );
  return res;
}
</script>

  <p>The good news is that we are done with the texture allocation part. The bad news is
  that we have to to the same for the buffers. Lukily, a buffer don't have all this
  "internal format", "format" and "type" stuff, it's just a blob of data, whose semantic
  is given later (many type of data will coexist in the same buffer, actually).<br />
  What it does have, however, is a "hint" flag, indicating if the buffer is likely to
  change and/or to be read often. This flag can take three times three values "STATIC" (won't change past
  the initialization, will be used many times), "DYNAMIC" (will change after initialization, and
  will be used many times) and "STREAM" (won't change after initialization,
  and will be used only a few times), combined with "DRAW", "READ" and "COPY" for ... well, go read
  the spec. It's an hint, it's not that constraining.<br />
  I picked DYNAMIC_DRAW, because we will change its content often and we will definitely reuse
  it many times, and its primary usage is to be drawn.
  </p>

  <div>
  More ranting.
    <details>
    If I can understand the reasoning behind this flag, I don't understand why OpenGL decided
    that the GPU can't figure that out itself. On your computer, the OS decides when to discharge
    some content from the RAM to the harddrive, and does that based on heuristics that indicates how
    likely is that content to be read/written in a near futur.<br />
    Based on similar heuristics (or even simpler ones: a change in a texture is done through an explicit
    function call, where you can do real work, it's not like an assembly instruction), the GPU
    could just determine how "hot" a buffer is, and transfer it from a kind of memory to another.
    </details>
  </div>

<script class="visible_script">
function gl_toolbox_create_buffer( toolbox, size )
{
  var gl = toolbox.gl;
  var res = {};
  res.id = gl.createBuffer();
  gl.bindBuffer( gl.ARRAY_BUFFER, res.id );
  gl.bufferData( gl.ARRAY_BUFFER, size, gl.DYNAMIC_DRAW );
  res.size = size;
  return res;
}

function gl_toolbox_resize_buffer( toolbox, old_buffer, new_size )
{
  var gl = toolbox.gl;

  var new_buffer = gl_toolbox_create_buffer( toolbox, new_size );

  gl.bindBuffer( gl.COPY_READ_BUFFER, old_buffer.id );
  gl.bindBuffer( gl.COPY_WRITE_BUFFER, new_buffer.id );
  gl.copyBufferSubData(
    gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER,
    0, 0, Math.min( old_buffer.size, new_buffer.size ) );
  gl.deleteBuffer( old_buffer.id );

  return new_buffer;
}
</script>

    <p>And as I mentionned, it would be nice to have something to
    resize a Javascript buffer as well. It does not involve gl,
    so I decided to have a different function signature (no "gl_toolbox", and
    no toolbox as a first parameter). Other than that, it works the same way:
    create a new, bigger, and copy from the old to the new one.<br />
    We won't be able to delete the old buffer, it will be garbage collected.<br />
    Lukily, the quirks of Javascript will make the code simpler than it may have been:</p>

<script class="visible_script">
function resize_js_buffer( buffer, new_size )
{
  var constructor = buffer.constructor;
  var res = new constructor(new_size);

  var len = Math.min( buffer.length, new_size );
  for ( var i = 0; i < len; i++ )
    res[i] = buffer[i];

  return res;
}
</script>


  <p>Before going to the next part, I would like to add some tools for the texture:</p>

  <ul>
    <li>Something to blit an opt_pixmap as described above to a texture with the
  appropriate type (RG8UI etc.).</li>
    <li>Something to set a rectangle to a texture with the appropriate type (RGBA16UI etc.).</li>
  </ul>

  <p>Binding multiple textures to a shader is both very simple and very ... hard to grasp.</br>
  It's one of those fields where nothing make sense but you have to apply the ritual
  nonetheless.</p>

<script class="visible_script">
function gl_toolbox_blit_opt_pixmap( toolbox, texture, opt_pixmap, x, y )
{
  var gl = toolbox.gl;
  gl.texSubImage2D( gl.TEXTURE_2D, 0,
    x, y,
    opt_pixmap.w, opt_pixmap.h,
    gl.RG_INTEGER, gl.UNSIGNED_BYTE,
    new Uint8Array( opt_pixmap.buf.buffer ) );
}
</script>

  <p>The tricky part is the last line. The opt_pixmap uses a Uint16Array.
  This is actually only a wrapper around an ArrayBuffer.<br />
  We cannot give this array to the texSubImage2D function directly, because
  the types don't match: it's expecting a byte array, and receives a short array.<br />
  Even if the sizes are correct (there is enough bytes in the Uint16Array),
  the types don't match.<br />
  The solution is to access the underlying ArrayBuffer of the Uint16Array,
  and to wrap it with a new wrapper, the Uint8Array the function wants.</p>

  <p>It's not as ugly as it may be.</p>

<script class="visible_script">
function gl_toolbox_blit_rectangle( toolbox, texture, rectangle, index )
{
  var gl = toolbox.gl;
  if ( toolbox.rect_array == null ) // if the buffer hasn't been created ...
    toolbox.rect_array = new Uint16Array( 4 ); // ... we create it now

  toolbox.rect_array[0] = rectangle.x;
  toolbox.rect_array[1] = rectangle.y;
  toolbox.rect_array[2] = rectangle.w;
  toolbox.rect_array[3] = rectangle.h;
  var dst_x = index % texture.w;
  var dst_y = Math.floor( index / texture.w );

  gl.texSubImage2D( gl.TEXTURE_2D, 0,
    dst_x, dst_y,
    1, 1,
    gl.RGBA_INTEGER, gl.UNSIGNED_SHORT,
    toolbox.rect_array );
}
</script>

  <p>Nothing noticeable here, except maybe the x/y calculation. The
  idea is that texture serves as an array. We use two dimensions only
  to avoid having a very long and thin texture, but it's a mean, not
  something we want for itself.<br />
  What we do want is an array, with an access with an index. So
  we hide the detail on how the rectangle will be stored and we present
  an interface requesting an index, not a position.</p>

  <p>We will implement more things for the texture but, before that, we need
  tools to manipulate shaders in the same way we manipulate textures.</p>

  <p>A tool to create it (empty, unusable as is):</p>
<script class="visible_script">
function gl_toolbox_create_shader( toolbox )
{
  var res = {};

  res.id = toolbox.gl.createProgram();
  res.uniforms = {};

  return res;
}
</script>

  <p>A tool to define the vertex and the fragment steps:</p>
<script class="visible_script">
function gl_toolbox_compile_step( toolbox, type, source )
{
  var gl = toolbox.gl;
  var step = gl.createShader(type);
  gl.shaderSource(step, source);
  gl.compileShader(step);
  if (!gl.getShaderParameter(step, gl.COMPILE_STATUS))
  {
    console.error(gl.getShaderInfoLog(step));
    throw new Error('Failed to compile step');
  }
  return step;
}

function gl_toolbox_define_vertex_and_fragment_steps(
  toolbox, shader,
  vertex_source, fragment_source )
{
  var gl = toolbox.gl;
  var vertex_step = gl_toolbox_compile_step( toolbox, gl.VERTEX_SHADER, vertex_source );
  var fragment_step = gl_toolbox_compile_step( toolbox, gl.FRAGMENT_SHADER, fragment_source );

  gl.attachShader(shader.id, vertex_step);
  gl.attachShader(shader.id, fragment_step);
  gl.linkProgram(shader.id);
  if (!gl.getProgramParameter(shader.id, gl.LINK_STATUS))
  {
    console.error(gl.getProgramInfoLog(shader.id));
    throw new Error('Failed to link shader');
  }
}
</script>

  <div>
    More ranting.
    <details>
    Yes, in OpenGL the vertex and fragment steps are called shaders
    (which is arguably ok) but the shader itself is called program, which
    is stupid as this word is already used to point to ... the program itself,
    what people usually name program.<br />
    Not to mention that, unlike framebuffers, textures and buffers, you don't
    bind/unbind a "program" and then reference it by its location. No,
    you directly use its name.<br />
    Even to activate it, you don't bind it, you "use" it (glUseProgram).
    And WebGL uniformized this a bit, because in OpenGL you create textures
    with "genTextures", buffers with "genBuffers" and framebuffers with
    "genFramebuffers" but you create programs with ... "createProgram".<br />
    <br />
    One may argue that you are likely to create many buffers/textures and framebuffers
    at once, while usually you'll only have one program. I disagree, as I very
    often have more than one program and it's quite rare that I use more than
    the default framebuffer.<br />
    Plus, shaders (the vertex and fragment) are also created one by one
    with "createShader", not "genShaders", and usually you'll use at least two
    shaders per program.<br />
    <br />
    No, it just sounds like Kronos changed their mind about how things should
    be, and they jumped on the opportunity to uniformize stuff with the WebGL API.<br />
    It's bad, because if anything the API should have uniformize stuff in the
    direction of gen*, not create*, as the first is there for a reason: it allows
    for optimizations and less back and forth between to GPU and the CPU.<br />
    And to make things even less coherent, you have, next to "createProgram",
    a set of functions "gen/delete/is/bind ProgramPipelines" ...
    and a function called <strong>create</strong>ProgramPipeline</strong>s</strong>,
    that has the same signature as the genProgramPipelines (so returning multiple
    values) ...<br />
    <br />
    After all, I think that they may all be drunk, at Kronos.
    </details>
  </div>

  <p>Now we can create a function to bind all textures at the same time:</p>
<script class="visible_script">
function gl_toolbox_bind_textures( toolbox, shader, textures )
{
  var gl = toolbox.gl;
  gl.useProgram( shader.id );

  var i = 0;
  for ( var k in textures )
  {
    var loc = shader.uniforms[k];
    if ( ! loc )
    {
      loc = gl.getUniformLocation( shader.id, k );
      shader.uniforms[k] = loc;
    }

    if ( loc == -1 )
      continue;
    gl.activeTexture( gl.TEXTURE0 + i );
    gl.bindTexture( gl.TEXTURE_2D, textures[k].id );
    gl.uniform1i( loc, i );
    i++;
  }
}
</script>

    <p>And the mirror function, to unbind:</p>
<script class="visible_script">
function gl_toolbox_unbind_textures( toolbox, shader, textures )
{
  var gl = toolbox.gl;
  var i = 0;
  for ( var k in textures )
  {
    var loc = shader.uniforms[k];
    if ( loc == -1 )
      continue;
    gl.activeTexture( gl.TEXTURE0 + i );
    gl.bindTexture( gl.TEXTURE_2D, null );
    i++;
  }
}
</script>


    <p>And it's all for our toolbox. With that we can start to implement higher level
    tools: the atlas and the buffer smart access.</p>

    <p>An atlas is well known thing but even if its concept is easy to grasp, its actual implementation
    isn't trivial. I never managed to obtain something satisfying.<br />

    <p>The problem lies in the lifespan of the textures inside the atlas.<br />
    For small textures (like in Doom) they can remain there forever, but with larger
    textures it is not an option. In that case, you have to detect that a texture
    can be unloaded, can be removed temporarly from the canvas of the atlas.<br />
    How do you do that ? There is several options, and none of them sounds good to me:</p>

    <ul>
      <li>You can require that the program explicitely state when it starts/stops
      using a texture. When the count usage drops to zero, you mark the texture
      as unloaded and its area reusable. It would be a good idea to remember
      that this texture was there, though, just in case the program wants to
      use it again right away.<br />
      Of course this solution only works if you have a full control on the
      acquiring and releasing of the textures.</li>
      <li>You can detect each frame which texture is being used. Actually,
      each frame the program will have to signify the textures it wants to
      use. If a texture is missing during one frame, it is considered as unloaded.<br />
      Same as above, remembering that the texture was there could be a good idea.</li>
      <li>This texture management sounds a lot like a standard memory management. And it
      kind of is, which means that any strategy used to manage memory can be used there, including
      a garbage collector Java-style. But it supposes tons of things that you'll never have unless
      you roll your own scripting language, more or less.</li>
    </ul>

    <p>Here, we have a total control over the textures usages. We know when we start using
    them and when we stop. We could go with the second option, but for the sake of simplicity
    I'll go with the "never remove the texture" option. We will improve that later, anyway.</p>

<script class="visible_script">
function create_atlas( toolbox, images_manager )
{
  var atlas = {};

  atlas.toolbox = toolbox;
  atlas.images = images_manager;
  atlas.canvas = gl_toolbox_create_atlas( toolbox, 256, 256 );
  atlas.layout = gl_toolbox_create_atlas_layout( toolbox, 30 );

  atlas.cursor = {
    x: 0,
    line: {
      y: 0,
      height: 0
    }
  };

  atlas.dictionnary = eve_create_tree( function( e1,e2 ){
    var v1 = e1.key;
    var v2 = e2.key;
    if ( v1.type != v2.type )
    {
      if ( v1.type < v2.type )
        return -1;
      else
        return +1;
    }
    else if ( v1.name != v2.name )
    {
      if ( v1.name < v2.name )
        return -1;
      else
        return +1;
    }
    else
      return 0;

  } );
  atlas.modified = [];

  return atlas;
}
</script>

    <p>This create an empty atlas, with an empty canvas of 256*256 pixels and
    an empty layout array of 30 entries. Arbitrary.<br />
    The cursor is less obvious, so let's take a little time to talk about it.<br />
    What we will implement is a "flow layout": each element is added after the next
    one, unless this would exceed the line width. In that case, we start a new line
    and add the element on this new line.<br />
    The actual height of the line depends on the height of the elements contained in
    that line. It's the "max" of those heights.<br />
    The structure of the cursor is a bit weird, but it is in anticipation of
    what will come after.
    </p>

    <details>
      When we will improve our atlas and allow the removing of a texture, we will need to
      know the size of the freed area. This size includes the height of the line,
      which cannot be known at the time we allocate the area for the initial texture.<br />
      It cannot be known because further elements could increase the height of the line.<br />
      The solution is to give each entry not the height of the line, but a "pointer" to it.
      As more and more elements will be added to this line, the value pointed will be updated
      and this change will be available on each entry, automatically.
    </details>

    <script class="visible_script">
function atlas_acquire( atlas, identifier )
{
  var lookup = { key: identifier };
  if ( ! atlas.dictionnary.contains( lookup ) )
  {
    var image = atlas.images( identifier );
    if ( atlas.cursor.x + image.w > atlas.canvas.w )
    {
      atlas.cursor.line = {
        y: atlas.cursor.line.y + atlas.cursor.line.height,
        height: 0
      };
      atlas.cursor.x = 0;
    }

    atlas.cursor.line.height = Math.max( atlas.cursor.line.height, image.h );

    var entry = {
      key     : { type: identifier.type, name: identifier.name },
      image   : image,
      x       : atlas.cursor.x,
      w       : image.w,
      line    : atlas.cursor.line,
      location: atlas.dictionnary.size()
    };

    atlas.cursor.x += image.w;
    atlas.dictionnary.add( entry );

    atlas.modified.push( entry );
  }

  return atlas.dictionnary.get_same( lookup ).location;
}

function atlas_release_texture( atlas, texture )
{
  // nothing for now
}
</script>

    <p>This function does not actually update the pixels. Maybe (likely) the user will require
    several textures during one frame, and we want to minimize the number of times we resize our
    atlas' canvas.</p>

    <p>But it means we need a validation step. During this validation we need to do
    several things:</p>

    <ul>
      <li>Ensure the atlas' canvas is big enough.</li>
      <li>Ensure the atlas' layout is big enough.</li>
      <li>Update the canvas, by bliting each new texture onto the canvas.</li>
      <li>Update the layout, by bliting each new texture's location onto the layout.</li>
      <li>Note that the atlas has been validated (by cleaning pending modifications).</li>
    </ul>

<script class="visible_script">
function atlas_validate( atlas )
{
  if ( atlas.modified.length == 0 )
    return;

  var needed_size = atlas.cursor.line.y + atlas.cursor.line.height;
  if ( atlas.canvas.h < needed_size )
  {
    var new_height = atlas.canvas.h;
    while( new_height < needed_size )
      new_height = Math.floor( new_height * 1.3 ) + 1;

    atlas.canvas = gl_toolbox_resize_texture( atlas.toolbox,
      atlas.canvas, atlas.canvas.w, new_height );
  }

  needed_size = atlas.dictionnary.size();
  if ( atlas.layout.w*atlas.layout.h < needed_size )
  {
    var new_height = atlas.layout.h;
    while( new_height*atlas.layout.w < needed_size )
      new_height = Math.floor( new_height * 1.3 ) + 1;

    atlas.layout = gl_toolbox_resize_texture( atlas.toolbox,
      atlas.layout, atlas.layout.w, new_height );
  }

  var gl = atlas.toolbox.gl;

  gl.bindTexture( gl.TEXTURE_2D, atlas.canvas.id );
  for ( var i = 0; i < atlas.modified.length; i++ )
  {
    var e = atlas.modified[i];
    gl_toolbox_blit_opt_pixmap( atlas.toolbox, atlas.canvas, e.image, e.x, e.line.y );
  }

  gl.bindTexture( gl.TEXTURE_2D, atlas.layout.id );
  for ( var i = 0; i < atlas.modified.length; i++ )
  {
    var e = atlas.modified[i];
    gl_toolbox_blit_rectangle( atlas.toolbox, atlas.layout,
      { x: e.x, y: e.line.y, w: e.image.w, h: e.image.h }, e.location );
  }

  // allow the garbage collection of the opt_pixmaps
  for ( var i = 0; i < atlas.modified.length; i++ )
    atlas.modified[i].image = null;

  atlas.modified = [];
}
</script>

    <p>We are not far from building our level's mesh, but there is still several steps.
    First: a smart access to the buffer. Like a I said, it's pretty useless if we only plan to add things in the mesh
    and never remove them. But we will need to remove primitives, for projectiles and lost
    souls/elemental of pain, if nothing else.<br />
    The problem is that I don't have a ready name for this component. "Smart access" is a bit generic,
    and "Mesh manager" isn't really better. I went with "primitive pool", both because it's a fun
    pun and because it's an image of a swimming pool: when you enter the pool (at least in my town)
    you receive a ring (a wrist ring) with a number on it. This ring identifies you, and when you leave
    the pool you give your ring back.</p>

    <p>So, here is the general behavior of this pool:</p>

    <ul>
      <li>When you enter the pool, you receive a ticket.</li>
      <li>When you leave the pool, you give your ticket back.</li>
      <li>Program only accesses primitives through this ticket.</li>
    </ul>

    <p>This allows the pool to move freely primitives around, to keep a compact
    buffer with whatever method it wants.</p>

    <p>For this implementation, I'll use the fact that, in 3D (by opposition with 2D gui/hud stuff),
    the order in which triangles are rendered has little to no impact, as long as we have a depth
    buffer, which we have.</p>

    <p>Strictly speaking, it has an impact, as rendering triangles in the
    correct order could avoid redrawing the same pixel many time.<br />
    But I would assume it has no impact, because even if it becomes a problem,
    you can just adjust the internal behavior of the pool to ensure whatever
    order you want.</p>

    <p>This is our strategy:</p>

    <ul>
      <li>When a primitive enters the pool, give it a ticket and append the primitive
      to the end of the buffer. If no ticket are available, just create a fresh new one.</li>
      <li>When a primitive leaves the pool, move the last primitive (the one at the end of the buffer)
      to this freed place. Put the released ticket into a basket, and update the ticket that
      used to point to the last entry of the buffer.</li>
    </ul>

    <p>This strategy can be implemented in several ways, depending whether you want to minimize
    the use of RAM on the CPU or if you want to decrease the GL calls.</p>

    <p>The first step is, once again, to create our tool:</p>

<script class="visible_script">
function create_primitive_pool( toolbox, primitive_size, primitive_to_binary )
{
  var res = {};

  res.toolbox = toolbox;
  res.primitive_size = primitive_size;
  res.primitive_to_binary = primitive_to_binary;
  res.blackboxify = (index) => index+1;
  res.unblackboxify = (ticket) => ticket-1;

  res.nb_primitives_max = 5;
  res.nb_primitives = 0;


  res.released_tickets = [];
  res.modified = eve_create_tree( compare_scalar );

  res.gpu_buffer = gl_toolbox_create_buffer( toolbox, res.nb_primitives_max * primitive_size );
  res.cpu_buffer = new Uint8Array( res.nb_primitives_max * primitive_size );
  res.ticket_to_primitive = new Uint32Array( res.nb_primitives_max );
  res.primitive_to_ticket = new Uint32Array( res.nb_primitives_max );

  return res;
}
</script>

    <p>The last parameter is a function that will be used to transform
    Javascript objects (the representation we will use in the rest of
    the program) into a blob of binary datas (what will be used in
    the shader).</p>

    <p>We already discussed the "enter" and "leave" operations for this
    primitive pool earlier. The "update" is much simpler,
    as there is no movement of ticket or primitives, just set the value.</p>

<script class="visible_script">
function primitive_pool_enter( primitive_pool )
{
  var pp = primitive_pool;
  if ( primitive_pool.released_tickets.length == 0 )
  {
    var new_ticket_index = pp.nb_primitives;
    if ( new_ticket_index == pp.nb_primitives_max )
    {
      pp.nb_primitives_max = Math.floor( pp.nb_primitives_max*1.3 ) + 1;

      pp.cpu_buffer = resize_js_buffer( pp.cpu_buffer, pp.nb_primitives_max * pp.primitive_size );
      pp.ticket_to_primitive = resize_js_buffer( pp.ticket_to_primitive, pp.nb_primitives_max );
      pp.primitive_to_ticket = resize_js_buffer( pp.primitive_to_ticket, pp.nb_primitives_max );
    }
    pp.released_tickets.push( new_ticket_index );
  }

  var ticket_index = pp.released_tickets.pop();
  var primitive_index = pp.nb_primitives;

  pp.ticket_to_primitive[ticket_index] = primitive_index;
  pp.primitive_to_ticket[primitive_index] = ticket_index;
  pp.nb_primitives = pp.nb_primitives + 1;

  return pp.blackboxify( ticket_index );
}

function primitive_pool_leave( primitive_pool, ticket )
{
  var pp = primitive_pool;

  // getting a bunch of index, for clarity (to avoid obscures expressions)
  var ticket_index = primitive_pool.unblackboxify( ticket );
  var index_of_removed_primitive = pp.ticket_to_primitive[ticket_index];
  var index_of_last_primitive = pp.nb_primitives-1;
  var ticket_index_of_last_primitive = pp.primitive_to_ticket[index_of_last_primitive];

  // copy from last to removed
  var start_of_removed = index_of_removed_primitive*pp.primitive_size;
  var start_of_last = index_of_last_primitive*pp.primitive_size;
  for ( var i = 0; i < pp.primitive_size; i++ )
    pp.cpu_buffer[start_of_removed + i] = pp.cpu_buffer[start_of_last + i];

  // updating arrows (ticket->primitive and primitive->ticket)
  pp.primitive_to_ticket[index_of_removed_primitive] = ticket_index_of_last_primitive;
  pp.ticket_to_primitive[ticket_index_of_last_primitive] = index_of_removed_primitive;

  // a primitive has been modified (the one removed)
  pp.modified.add( index_of_removed_primitive );

  // put the ticket in the basket
  pp.released_tickets.push( ticket_index );
}

function primitive_pool_update( primitive_pool, ticket, primitive )
{
  var pp = primitive_pool;
  var ticket_index = pp.unblackboxify( ticket );
  var index_of_primitive = pp.ticket_to_primitive[ticket_index];

  var start_of_primitive = index_of_primitive * pp.primitive_size;
  var view = new DataView( pp.cpu_buffer.buffer, start_of_primitive, pp.primitive_size );
  pp.primitive_to_binary( primitive, view );

  pp.modified.add( index_of_primitive );
}
</script>

    <p>And once again, it requires a validation step.<br />
    We have a set of modified primitives. We could update them
    one by one, but we can also deduce segments of modifications.<br />
    We could (but we won't) even decide to glue together two or more
    segments if the gap between them is small enough.</p>

<script class="visible_script">
function primitive_pool_validate( primitive_pool )
{
  if ( primitive_pool.modified.is_empty() )
    return;

  var pp = primitive_pool;
  var segments = [];

  var it = pp.modified.new_iterator();
  var seg_start = it.next();
  var seg_end = seg_start;

  while( it.has_next() )
  {
    var n = it.next();
    if ( n > pp.nb_primitives )
      break;

    if ( n == seg_end+1 )
      seg_end = n;
    else
    {
      segments.push( { start: seg_start, end: seg_end } );
      seg_start = n;
      seg_end = n;
    }
  }

  segments.push( { start: seg_start, end: seg_end } );
  pp.modified.clear();

  var gl = pp.toolbox.gl;
  var nb_primitives_gpu_side = pp.gpu_buffer.size / pp.primitive_size;
  if ( nb_primitives_gpu_side < pp.nb_primitives )
  {
    while( nb_primitives_gpu_side < pp.nb_primitives )
      nb_primitives_gpu_side = Math.floor( nb_primitives_gpu_side * 1.3 ) + 1;

    pp.gpu_buffer = gl_toolbox_resize_buffer( pp.toolbox, pp.gpu_buffer, nb_primitives_gpu_side * pp.primitive_size );
  }

  gl.bindBuffer( gl.ARRAY_BUFFER, pp.gpu_buffer.id );
  for ( var i = 0; i < segments.length; i++ )
  {
    var seg = segments[i];
    var seg_len = seg.end - seg.start + 1;

    gl.bufferSubData( gl.ARRAY_BUFFER,
      seg.start*pp.primitive_size, pp.cpu_buffer,
      seg_start*pp.primitive_size, seg_len*pp.primitive_size );
  }
}
</script>

    <h4>Camera</h4>
    <p>The complex stuff is done, but we need some final tools. Namely: a camera and the shader.</p>

    <p>I always found the setup of the camera tricky to say the least, painfull being a better term.
    For quite a long time now, you don't have the GL functions to operate on matrices,
    and there is always this uncomprehensible thing of left-hand/right-hand convention,
    and when you try to find some code online they never explain what they use.</p>

    <p>This is what I usually do:</p>

    <ul>
      <li>Find a library that does the stuff. However, as the only thing we need
      is perspective/rotation/translation, those libraries are always an overkill.</li>
      <li>Once things work with the library, find the mathematical equations that actually
      implement what you want.</li>
      <li>Now, does some transformation (with non-classical values) with both you library (which you know works),
      and with the implementation found online.</li>
      <li>Check they match, and if they don't (elements are swapped, with the opposite sign etc.)
      fix that in your implementation.</li>
      <li>Do that for every function, one by one. Check each time they are sync, after the correction.</li>
      <li>Now you can get rid of your library.</li>
    </ul>

    <details>
    <p>One may argue it's not clean, it's not proper programming, merely mimicing. One may
    also argue that by doing this I take credit for myself of the efforts done on those
    actually working implementation.</p>

    <p>For the first objection, I don't care. I want a working camera and I don't plan on
    doing complex sheningan with the projection matrix.</p>

    <p>The second objection is valid. However, nothing prevents me from saying which library
    I used to do that.</p>
    </details>

    <p>I did that using a javascript port of the glm library. The result is delivered as
    a mix of functions extracted from glm and functions of my own, packaged in a single
    function "create_camera". The code itself is not that important, but here it is:</p>

<script class="visible_script">
function create_camera()
{
  var res = {};
  res.x = -2.5;
  res.y = 0.3;
  res.z = 2;
  res.yaw = 0;
  res.pitch = 0;
  res.roll = 0;
  res.near = 1;
  res.far = 10000;
  res.fovy = 52;
  res.aspect = 1;

  res.matrix = new Float32Array( 16 );
  res.other = new Float32Array( 16 );
  res.tmp = new Float32Array( 16 );


  var deg_to_rad = Math.PI / 180.0;

  var _set_to_zero = function( out )
  {
    for ( var i = 0; i < out.length; i++ )
      out[i] = 0;
  }

  var _set_to_identity = function( out )
  {
    _set_to_zero( out );
    out[0] =
    out[5] =
    out[10] =
    out[15] = 1;
  }

  var _perspective = function( out, fovy, aspect, nearZ, farZ )
  {
    _set_to_zero( out );
    var f  = 1.0 / Math.tan(fovy * 0.5 * deg_to_rad);
    var fn = 1.0 / (nearZ - farZ);

    out[_index(0,0)] = f / aspect;
    out[_index(1,1)] = f;
    out[_index(2,2)] = (nearZ + farZ) * fn;
    out[_index(3,2)] =-1.0;
    out[_index(2,3)] = 2.0 * nearZ * farZ * fn;
  }

  var _rotateY = function( out, angle )
  {
    var rads = angle * deg_to_rad;
    var cos = Math.cos( rads );
    var sin = Math.sin( rads );

    _set_to_zero( out );

    out[_index(0,0)] = cos; out[_index(2,0)] = -sin;
    out[_index(1,1)] = 1;
    out[_index(0,2)] = sin; out[_index(2,2)] = cos;
    out[_index(3,3)] = 1;
  }

  var _rotateX = function( out, angle )
  {
    var rads = angle * deg_to_rad;
    var cos = Math.cos( rads );
    var sin = Math.sin( rads );

    _set_to_zero( out );

    out[_index(0,0)] = 1;
    out[_index(1,1)] = cos; out[_index(2,1)] = -sin;
    out[_index(1,2)] = sin; out[_index(2,2)] = cos;
    out[_index(3,3)] = 1;
  }

  var _translate = function( out, x, y, z )
  {
    _set_to_identity( out );
    out[_index(0,3)] = x;
    out[_index(1,3)] = y;
    out[_index(2,3)] = z;
  }

  function compose()
  {
    var A = res.matrix;
    var B = res.other;
    var d = res.tmp;

    for ( var i = 0; i < 4; i++ )
    {
      for ( var j = 0; j < 4; j++ )
      {
        var sum = 0;
        for ( var k = 0; k < 4; k++ )
          sum = sum + (A[_index(i,k)] * B[_index(k,j)]);
        d[_index(i,j)] = sum;
      }
    }

    for ( var i = 0; i < 16; i++ )
    {
      res.matrix[i] = d[i];
      res.other[i] = 0;
    }
  }

  res.to_gl_matrix = function()
  {
    _perspective( res.matrix, res.fovy, res.aspect, res.near, res.far );

    _rotateX( res.other, -res.pitch );
    compose();

    _rotateY( res.other, -res.yaw );
    compose();

    _translate( res.other, -res.x, -res.y, -res.z );
    compose();


    return res.matrix;
  }

  var _to_vector = function( yaw, pitch )
  {
    var yaw_rad = yaw * deg_to_rad;
    var pitch_rad = pitch * deg_to_rad;

    var cos_yaw = Math.cos( yaw_rad );
    var sin_yaw = Math.sin( yaw_rad );
    var sin_pitch = Math.sin( pitch_rad );

    var len = Math.sqrt(cos_yaw*cos_yaw + sin_yaw*sin_yaw + sin_pitch*sin_pitch);

    // no idea why I have to do this.
    len *= -1;

    return { x:sin_yaw/len, y:sin_pitch/len, z:cos_yaw/len };
  }

  res.front = function()
  {
    return _to_vector( res.yaw, res.pitch );
  }

  res.left = function()
  {
    return _to_vector( res.yaw + 90, res.pitch );
  }

  return res;
}
</script>

    <p>This implementation is <strong>highly</strong> suboptimal, and a more optimized
    implementation would be welcome.</p>

    <h4>Shader</h4>

    <p>Finally, here is the glsl shader we will use to render walls+flats+sky.<br />
    It's detailed below.</p>

    <p>The vertex shader</p>
<pre class="glsl_script" id="vertex_source">
#version 300 es
precision lowp int;
precision lowp float;
precision lowp isampler2D;

uniform mat4 u_camera;
uniform isampler2D u_atlas_layout;
uniform isampler2D u_sectors;
uniform uint u_sky_texture;
uniform vec3 u_camera_position;


in ivec3 a_position;
in ivec2 a_texcoord;
in uint a_sector;
in uint a_texture;

flat out ivec4 v_texture_area;
out vec2 v_texcoord;
flat out int v_colormap;
flat out int v_is_sky;
out vec3 v_direction;


void main()
{
  gl_Position = u_camera * vec4( vec3(a_position), 1.0 );

  v_direction = vec3(a_position) - u_camera_position;

  v_texcoord = vec2( a_texcoord );

  uvec2 layout_size = uvec2(textureSize( u_atlas_layout, 0));
  ivec2 layout_coord = ivec2(
    a_texture % layout_size.x,
    a_texture % layout_size.y );
  v_texture_area = texelFetch( u_atlas_layout, layout_coord, 0 );

  uvec2 sectors_size = uvec2(textureSize( u_sectors, 0 ));
  ivec2 sector_coord = ivec2(
    a_sector % sectors_size.x,
    a_sector / sectors_size.x );
  ivec3 sector = texelFetch( u_sectors, sector_coord, 0 ).rgb;

  v_colormap = (255 - sector.r)/8;

  v_is_sky = a_texture == u_sky_texture?1:0;
}
</pre>

  <p>The fragment shader</p>
<pre class="glsl_script" id="fragment_source">
#version 300 es
precision lowp int;
precision lowp float;
precision lowp isampler2D;

const float PI = acos(-1.0);
const int NB_REPEAT_HORIZONTAL = 4;

uniform isampler2D u_atlas;
uniform isampler2D u_colormap;
uniform sampler2D u_playpal;

uniform int u_used_playpal;


in vec2 v_texcoord;
flat in ivec4 v_texture_area;
flat in int v_colormap;
flat in int v_is_sky;
in vec3 v_direction;

out vec4 o_FragColor;

ivec2 my_mod( ivec2 x, ivec2 y )
{
  return (((x%y)+y)%y);
}

vec2 direction_to_coords(in vec3 dir)
{
  float angle_x = float(NB_REPEAT_HORIZONTAL) * (((atan(dir.z, dir.x) / PI) + 1.0) / 2.0);
  float angle_y = -dir.y + 0.5;
  return vec2( angle_x, angle_y );
}

void main()
{
  if ( v_is_sky == 1 )
  {
    vec3 dir = normalize(v_direction);
    ivec2 pos = ivec2(direction_to_coords(dir)*vec2(v_texture_area.zw));
    pos.x = (((pos.x%v_texture_area.z)+v_texture_area.z)%v_texture_area.z);
    pos.y = clamp(pos.y, 0, v_texture_area.w);
    pos = pos + v_texture_area.xy;

    int index = texelFetch( u_atlas, pos, 0 ).r;

    vec4 color = texelFetch( u_playpal, ivec2( index, 0 ), 0 );
    o_FragColor = vec4( color.rgb, 1 );
    return;
  }

  ivec2 texcoord = ivec2( v_texcoord );
  texcoord = my_mod(texcoord, v_texture_area.zw);
  texcoord = texcoord + v_texture_area.xy;

  ivec2 pixel = texelFetch( u_atlas, texcoord, 0 ).rg;
  if ( pixel.g != 1 )
    discard;

  int index = pixel.r;

  int reindex = texelFetch( u_colormap, ivec2( index, v_colormap ), 0 ).r;
  vec4 color = texelFetch( u_playpal, ivec2( reindex, u_used_playpal ), 0 );

  o_FragColor = vec4( color.rgb, 1);
}
</pre>

    <p>Some explanations. A lot, actually.</p>

    <ul>
      <li>Like I said, we use WebGL2, but, by default, shaders are still compatible
      with WebGL1 and incompatible with WebGL2. Yes, it's f*cking absurd, that you can
      use the function vertexAttribIPointer on the CPU side and cannot retrieve it
      on the GPU side, because the shader doesn't allow for integer attributes.<br />
      The key is to explicitely say "use WebGL2-compatible shaders", because it wasn't
      explicit enough when we asked for a WebGL2 context in the first place. So the line
      <pre class="glsl_script">#version 300 es</pre>.
      </li>
      <li>
        In GLSL, the modulus operator "%" doesn't respect the mathematical definition of this operation,
        which is the smallest <strong>positive</strong> value such as blablabla.<br />
        Here the operator can yield negative values: "(-2)%5" will return "-2", not "3", like it should.<br />
        If you don't believe my, try that on your calculator or on your excel-like program.<br />
        <br />
        No matter what, we need the real "modulus" and this is what the sequence "((x%y)+y)%y)" does:
        <ol>
          <li>"x%y" will take any number as x and return something in ]-y;+y[</li>
          <li>"+y" will turn it into ]0;2y[.</li>
          <li>"%y" will turn it into [0;y[.</li>
        </ol>
        Not only that, but it does actually return what we want (a proof of that is left as an exercice to the reading :) ).
      </li>
      <li>
        The calculation of the sky is so different than the rest of the level that
        it has its own "if" which doesn't share any data with the "else" (it returns).<br />
        I could have put it into its own rendering pass, but I needed to move on from this
        chapter.<br />
        Even the calculation is awefull, and I would appreciate some help here. The problem
        comes from the fact that in a WAD you don't have a cubemap for the sky, but a cylinder.
        A texture is repeated 4 times on the cylinder, horizontally.<br />
        And in Vanilla Doom, you cannot look up or down.<br />
        So it was fine for Doom, but isn't for us. I am not proud of my implementation, which
        is a copy-past of what I did back in 2016.
      </li>
    </ul>


    <h3>The first rendering</h3>

    <p>Here is a small summary of what we did in the last chapter:</p>

    <ul>
      <li>The manipulation of textures (allocation, resize, update)</li>
      <li>The manipulation of buffers (allocation, resize, update)</li>
      <li>An atlas, to store all the textures we need.</li>
      <li>A smart primitives (triangle/quad) pool manager.</li>
      <li>A camera.</li>
    </ul>

    <p>Ok, that was a long road of WebGL-specific stuff and low level
    plumbing, but we can, at last, go back to Doom.</p>

    <p>Here is a quick summary of what we will do now:</p>

    <ul>
      <li>Render all the map, as a unmodifiable blob of primitives.</li>
      <li>Implement a "fly cam".</li>
      <li>Split the map into small independent pieces, to allow for a changing
      of ceiling's height (opening a door), of floor's height (elevator), or wall
      texture (switches) without having to redraw all the map.</li>
      <li>Reduce the number of primitives rendered using some funky algorithms.</li>
    </ul>

    <p>What we will do now is to try to render the whole map, . But it's only temporary: once we will have this, and a way
    to move around (to check everything is ok) we will move to the second part,
    the optimization. We will need it, as we will have to open doors, to activate
    crushers and change switches textures, and we don't want to redraw all the
    map each time we do this.</p>

    <p>We could just took all the triangles we made during the tessellation
    and all the walls made by the linedefs and render all of that and <i>voilà</i>.<br />
    But it's not a good idea: we will need to open doors, to activate crushers and it
    may also be nice to optimize a bit the rendering. This approach would force us
    to redraw everything every tick a door is opening.</p>

    <p>We can do it this way: ("triangle" refers to the elements of the tessellation)</p>
    <ul>
      <li>Each triangle will be toogleable for the rendering.</li>
      <li>Each triangle will have a set of primitives attached to it,
      corresponding to its floor, its ceiling and its walls.</li>
      <li>Updating a triangle will update all of its primitives.</li>
      <li>Updating a sector will update all of its triangles and its immediatly adjacent triangles.</li>
    </ul>

    <p>It is <strong>a bit</strong> inefficient, we will update a bit to much primitives
    (the floors, ceilings and not-concerned walls of immediatly adjacent triangles of an
    updated sector). A more optimized version of that would allow for a per-wall update.
    But it's a small optimization, and we have other things to do now.</p>


    <p>NOTE: as I was writting this document, I found a problem in
    one of my algorithm. I am working on solving it, but so far in spite of
    the progresses I made, I didn't manage to fix it entirely.<br />
    This algorithm isn't necessary to render the level, so we can proceed.<br />
    In a nutshell, this algorithm answer the question whether a field-of-view is closed
    after traversing N segments. It is required to determine which sector can view which
    sector, which is required to reduce the number of primitives we draw.<br />
    I changed the order of this chapter, pushing the optimization in the last part, so
    I have more time to fix it.
    </p>

    <p>Here is how we can implement the drawing of the map:</p>

    <ol>
      <li>We can solve the question at a triangle level (triangle in the sense tessellation).
      It will involve determining the primitives for the floor, the ceiling and the walls
      of that triangle. The walls, especially, will require a bit of attention because of unpegged
      stuff.</li>
      <li>Once we have this basic level, we can build a routine displaying a sector: display
      all of its triangles.</li>
      <li>Once we have this routine, we can draw the whole map, by displaying each sector.</li>
      <li>For updating, we need to identify what could change:
        <ul>
          <li>When changing the texture of a wall, only that wall changes. Because
          we don't have a grain at a wall-level, we will have to redraw the whole triangle.</li>
          <li>When changing the height of the floor/ceiling of a sector it, of course,
          affects every primitives of this sector. But it also affect immediatly adjacent walls
          of other sectors (it affects both side of a double sided linedef).</li>
          <li>We will only change primitives that are actually displayed. If a primitive
          update is issued for a non-displayed primitive, it will be discarded.</li>
        </ul>
      </li>
    </ol>

    <p>As all of that rely on the possibility to solve the problem on a triangle problem,
    let's address that. A triangle comprises several primitives, and if we can solve
    all of them, we can solve the triangle's problem easily:</p>

    <ul>
      <li>The floor and the ceiling. Because we use culling of backfaces, what will be
      the correct order for the floor will be the inverse order for the ceiling, and vice versa.<br />
      Those two primitives are visible iff the floor is lower than the ceiling. If it's equal
      (like for doors) or higher (which should be an invalid case but can be found anyway)
      no primitives should be issues for those two part (and for the whole triangle, actually).</li>
      <li>The walls. Our triangle has possibly three walls, but the solution for one will work
      for the others.<br />
      First of all, if no ceiling/floor primitives are issued for this triangle, we can discard
      walls as well. The reason why is that in such a sector (that has its floor's height greater
      or equal than its ceiling's height), the player cannot exists, neither the view.<br />
      Second, a wall is made of three parts. Sadly, we cannot just resolve one of them
      and report the solution on the two others, they each have their own weird way to be.</li>
    </ul>

    <p>Let's address those wall. As said previously, a wall is made of three parts: the upper part,
    the middle part and the lower part.</p>

    <p>The upper and lower parts are used only on double-sided linedefs. The middle part is
    used on single-sided linedef, but can also be used on double-sided linedef, to create
    a intangible wall (like the exit of the secret passage in the acid area, in E1M1),
    and grids (like near the exit in E1M1).</p>

    <p>A double-sided linedef has, by definition, two sides. As each side points to a sector,
    a double-sided linedef deals with two sectors (possibly the same, it doesn't matter).</p>

    <p>As a sector has (among other things) a floor height and a ceiling height, a double-sided
    linedef deals with two pairs of height (floor-floor and ceiling-ceiling). When the two
    elements of a pair are the same (same floors' heights or same ceilings' heights) there is no
    gap to fill. But when they mismatch, there is a gap to fill, and it's where the upper and
    lower part becomes relevant.</p>

    <p>Now, each pair's mismatch will create only one gap. A gap will appear when
    standing on the lowest floor and looking at the highest floor, or when standing under
    the highest ceiling and looking at the lowest. We have one gap per mismatching pair, not two.</p>

    <p>So far, nothing really hard. The problem comes with the texture alignment, and the unpegged attributes.</p>

    <p>If there is no offset, no unpegged, no specific setting, what will we see on a wall that has
    all of its three parts ?<br />
    For the upper part, the bottom-left corner of the image will be at the bottom-left corner of the wall.
    If the wall is not tall enough to display the whole texture's height, the top of the texture
    will be missing.
    <br />
    For the middle and the lower part things are inverted: the top-left corner of the texture matches the top-left
    corner of the image. If the wall is not tall enough to display the whole texture's height, the bottom of
    the texture will be missing.<br />
    I don't know the rational behind this (and you may guess one) but it's like that.</p>

    <p>If you have troubles remembering that, you can do it like this:</p>

    <ul>
      <li>Remember that we have upper on one side and lower+middle on the other.</li>
      <li>Remember that a door is basically a low ceiling, displaying the upper part.
      Now, when a doors open, what happen to the texture on the door ? Answer that
      and you'll remember how things work for all three parts.</li>
    </ul>

    <p>Added to this, you can change the offset of a texture manually (even if you can't do
    it individually for each part, as the offset will apply to all three parts) and for static
    scenes it should let you achieve most of the things you may want to do. The problem
    arises with moving flats (floors and ceilings).</p>

    <p>When a door opens, things seems ok: as the door is actually a "low ceiling" that rises
    to let you pass, the texture displayed on the door is the upper-part of the wall. Because
    of this, it is drawn bottom-up, and as the ceiling rises the texture will seem to rise with it.<br />
    But what about the borders of the door ? (what let the door slides in).</p>

    <p>They are usually single-sided linedef and, because of this, the texture displayed is
    the middle part. As such, it is drawn from the top to bottom, with the top of the texture
    matching the top of the wall. As the door rises, the top of the wall will rise and the
    texture will rise with it.</p>

    <p>To avoid that, we need to tell to the wall that, unlike usual, the texture must
    be drawn bottom-up, the bottom past must not move when the ceiling is rising. And it's exactly
    what "lower unpegged" does.</p>

    <p>"upper unpegged" does the same thing, but for the upper-part: if it is set, the texture
    will be drawn top-down, instead of the usual for the upper-part, bottom-up.</p>

    <p>But if you only do that, you won't obtain the desired result. For most of
    the walls, the alignment will be ok, but some of them won't appear as they should.<br />
    This is because on the lower-part, the "lower unpegged" flag does more than what I said.
    It does what I said, but it does more too.</p>

    <p>Which is sad, because up to now we could have only tagged each wall as "bottom-up" or
    "top-down" and let the shader calculate the correct alignment. Basically, the lower being
    unpegged involves the BACK sector floor's height.<br />
    However, instead of diving into complex explanations on how things works, I'll give 6
    equations, that describes position of the texture on the upper corner. Deducing the
    position of the texture on the lower corner is trivial (but we'll do it anyway).<br />
    Positive values means the texture is moving upward (elevating).
    </p>

<script class="visible_script">
function calculate_texture_position_upper_corner(
  wall_part, // either 'U', 'M' or 'L'
  is_unpegged, // true or false
  front_ceiling_height,
  back_ceiling_height,
  back_floor_height)
{
  switch( wall_part )
  {
    case 'U':
      if ( is_unpegged ) return 0;
      else               return back_ceiling_height - front_ceiling_height - 1;
    case 'M':
      if ( is_unpegged ) return back_floor_height - back_ceiling_height;
      else               return 0;
    case 'L':
      if ( is_unpegged ) return front_ceiling_height - back_floor_height;
      else               return 0;
  }
}
</script>




    <p>We could, instead of rendering the whole level all the time, render
    only what the user can see. Finding the precise set of primitives viewed by the
    user would basically require to render the whole scene, defeating any (or
    at least most) optimization we could obtain from that information.<br />
    But we can approximate this, and have a per-triangle knowledge of what is viewable
    or not.
    </p>

    <p>How do we obtain that ? It's not trivial, but I will go step by step, with examples
    (it should remind you of the first chapter).</p>

    <p>Let's put a definition: <dfn>a point A can view B if and only if there exists a line
    going from A to B.</dfn></p>

    <p>But fear not: we are NOT going to cast hundred of thousands of lines, hoping
    to find what is viewed and what isn't. It would be inefficient and time consuming,
    as well as unaccurate.</p>

    <p>In an open world, the world is empty by default: an A can always see a B (there is always a line
    going from a point to an other) and as we add objects (like walls, rocks,
    buildings etc) into the scene we make some line impossible.</p>

    <p>But Doom is a closed world. A closed world is full by default, an A can never see a B,
    and as we excavate areas, we make some line possible.</p>

    <p>In Doom a "line going from A to B", will have to exists entirely inside
    excavated areas (the "sectors").</p>

    <p>From there we can put a second definition, derived from the first one:
    <dfn>A triangle T1 can view a triangle T2 if and only if there exists
    a point A in T1 and a point B in T2 and a "A can view B"</dfn>.</p>

    <p>We can derive a third definition, but we aren't going to use it much:
    <dfn>A sector S1 can view a sector S2 if and only if there exists
    a triangle T1 in S1 and a triangle T2 in S2 and "T1 can view T2"</dfn>.</p>

    <p>Now, as we know that a line can only exists if it lies entirely inside
    excavated areas, we can deduce that no line (or no "valid" line) crosses
    a single-sided LINEDEF. It can cross double-sided LINEDEF, though.
    </p>

    <p>So, if we have an algorithm that can answer the question "given a set of segments,
    is there a line crossing all of them" we will have a first step in the resolution of the problem.</p>

    <p>The segments will represent a side of T1, a side of T2 and all the intermediate
    triangles' sides between T1 and T2. If there is a line crossing all of those segments,
    T1 can see T2.</p>

    <p>Please note that, because it is important: we want to know <strong>if</strong>
    a line exists, not <strong>which</strong> line it is.</p>

    <p>So, how do we do that ? I spent years (not full time, though) trying to find
    an answer to that. The answer is actually quite simple, and very weird and unintuitive.</p>

    <p>Let's take a set of segments:</p>

    <p>If you where in a universe on the left of the left-most segments, and you were able
    to see only through this first segment, what would be your field of view ?
    A 180 degrees. That's it, if you stand at the bottom most of the segment and look
    upward, and then go to the other side of the segment and look downward, this will
    cover an area of 180 degrees.</p>

    <p>Now, what if you have to see through two segments ? (the two left most).
    You have to stay behind the first segment.</p>

    <p>As we add more and more segments, the vector

    </p>
<script>

function draw_segments( ctx, segments )
{
  for ( var i = 0; i < segments.length; i++ )
  {
    var segment = segments[i];
    ctx.strokeStyle = segment.color;
    ctx.beginPath();
    ctx.moveTo( segment.A.x*15, segment.A.y*15 );
    ctx.lineTo( segment.B.x*15, segment.B.y*15 );
    ctx.stroke();
    ctx.closePath();
  }
}

var fov_segments = [
  { A:{ x:10, y:10 }, B:{ x:10, y:20 } },
//  { A:{


];

</script>














































    and if a line exist


    will go through their edges. We can represent A and B as separated by a certain
    number of segments, and A can see B if and only if there exists a line
    going from A to B while crossing all of those segments.</p>



    <p>What we will do, instead, is associate a set of primitives to each
    sector</p>
    <p>A map, in Doom, is made of sectors. Each sector is split in triangles,
    and each side of the triangle may correspond to a linedef of the WAD.</p>







    <p>I got stuck quite a long time when writing this document. Not because I
    didn't know what to do or how to do it, but because I wanted to go too fast
    and I ended up using things I did not introduce first.<br />
    So I went back and decided to go slower. Let's try to setup the rendering above,
    for a static triangle that will use a static texture.</p>

    <p>We will need shaders. The code of those shader will determine
    what we have to send, so let's write them first.</p>

    <p>The vertex shader:</p>
<code class="glsl">
in ivec3 position;
in ivec2 texcoord;
in int sector;
in int texture;

void main()
{
  gl_Position = vec4( position, 1 );
}
</code>

    <p>The fragment shader:</p>
<code class="glsl">
nothing here for now

</code>

    <p>We need to create a buffer for our triangle:</p>
<script class="visible_script">
var gl_step1 = {};

gl_step1.create_buffer = function( gl )
{
  /*gl_step1.buffer_id = gl.CreateBuffer();
  gl.bindBuffer( gl.ARRAY_BUFFER, gl_step1.buffer_id );
  gl.bufferData( gl.ARRAY_BUFFER,*/
}
</script>
























    <h3>The winning ticket</h3>
    <p>For our rendering, we need a way to represent triangles. We want to be able
    to add and remove them easily, and for a low cost.<br />
    I developped a solution for that several years ago, and I'll use it here. It a bit weird
    and you can easily get lost, but I'll do my best.</p>

    <p>First, let's represent the problem.</p>

    <p>We have an array, containing triangles, identified here by v1, v2, ... vn.</p>

    <div class="center">
    <canvas id="triangle_pool_1-canvas" width="64" height="32">
    </canvas>
    </div>

    <script>
    function triangle_pool_create_cell( ctx, str )
    {
      return {
        text: str,
        w: ctx.lineWidth( str ),
        h: ctx.lineWidth( "M" ),
        x: 0,
        y: 0
      };
    }
/*
    function triangle_pool_layout_cells( row1, row2 )
    {
      for ( i = 0; i <
    }
*/

    on_body_loaded.push( function() {
      var canvas = document.getElementById("triangle_pool_1-canvas");
      var ctx = canvas.getContext("2d");

      ctx.fillStyle = "lightgreen";
      ctx.fillRect( 0, 0, canvas.width, canvas.height );
      ctx.fillStyle = "black";

      ctx.fillText( "Hello world", 0, canvas.height );

      var cells = [
        { text: "v1" },
        { text: "v2" },
        { text: "v3" },
        { text: "..." },
        { text: "vn" }
      ];

      ctx.font = "25px monospaced";
      var margin = 3;
      var w = 0;

      for ( var i = 0; i < cells.length; i++ )
      {
        var cell = cells[i];
        cell.x = w;
        w += 2*margin;
        w += ctx.measureText( cell.text ).width;
        w += 1; // border
      }

      w += 1;
      var h = ctx.measureText("M").width + 2*margin;

      console.log( ctx.imageSmoothingEnabled );
      w = Math.floor(w);
      h = Math.floor(h);
      canvas.width = w+1;
      canvas.height = h+1;

      ctx.imageSmoothingEnabled = false;
      ctx.translate(0.55, 0.5);
      ctx.font = "25px monospaced";

      ctx.imageSmoothingEnabled = false;

      console.log(w, h);
      ctx.strokeStyle = "black";
      ctx.fillStyle = "black";


      ctx.beginPath();
      ctx.moveTo( 0, 0 );
      ctx.lineTo( w, 0 );
      ctx.lineTo( w, h );
      ctx.lineTo( 0, h );
      ctx.stroke();
      ctx.closePath();

      DEBUG = ctx;


      for ( var i = 0; i < cells.length; i++ )
      {
        var cell = cells[i];
        ctx.fillText( cell.text, cell.x + margin + 1, h - margin - 1 );
      }

      ctx.beginPath();
      for ( var i = 0; i < cells.length; i++ )
      {
        var cell = cells[i];
        ctx.moveTo( cell.x, 0 );
        ctx.lineTo( cell.x, h );
      }
      ctx.stroke();
      ctx.closePath();

    } );
    </script>

    <p>The problem with the naive approach is that: if we remove, let's say, the triangle v2, we will have to
    move all the triangles from v2 to vn.</br >
    It's not a lot of work for us, we only have to code a "for" loop, but its potentially
    a lot of work for the computer, depending on how many triangles are actually in there.<br />
    We cannot even ask the GPU to do that for us, because copying an array to itself
    with overlapping areas is usually not allowed.</p>

    <p>
    The solution is that: those triangles don't have to be in THAT order. Whatever
    the order is, the result of the rendering will be the same (at least in 3D,
    we will talk about the 2D after).<br />
    By using that trick, we can implement the action "remove v2" by
    copying the data of vn at the location of v2 (and decrease the number
    of rendered triangles by one, of course).</p>

    <p>But it creates a new problem: if we want to modify (or remove) what used
    to be vn, it's no longer where it used to be. We could setup an overcomplicated
    system of listeners to notify the owners of "vn" that it moved, but, as stated,
    it would be over complicated.</p>

    <p>As usual in computer science, the solution is a level of abstraction. This one
    is implemented as follow:</p>

    <ul>
      <li>Triangles cannot be accessed directly.</li>
      <li>When a triangle is created, it generates a "ticket".</li>
      <li>This ticket is what the rest of the program will use to access the triangle.</li>
      <li>A ticket is a black box. It has no meaning for the rest of the program,
      except that it's a way to access a triangle.</li>
      <li>The association ticket->triangle is maintained somewhere, and updated
      when a triangle is moved in the buffer.</li>
    </ul>

    <p>In our implementation, the blackbox-ification of a ticket will be done
    by adding 1 to the index of the ticket. It could be anything, even a no-op.</p>

    <p>To update the association ticket&lt;-&gt;triangle, we will need two arrays:</p>

    <ol>
      <li>One array implementing ticket-&gt;triangle.</li>
      <li>One array implementing triangle-&gt;ticket.</li>
    </ol>

    <p>On top of that, we will also need a way to store the actual triangles.
    It can be backed up on the CPU or exist solely on the GPU, there is several
    ways of implementing that. I list three of them here:</p>

    <ol>
      <li>Store nothing on the CPU. Each time something has to be done,
      it must be done now, immediatly.<br />
      Pro:
        <ul>
          <li>No duplication of the data.</li>
        </ul>

      Cons:
        <ul>
          <li>A lot of small messages are sent to the GPU.</li>
          <li>Depending on the implementation, each message may stall
          the application until the message is fully processed.</li>
          <li>Each time we need to resize the buffer of triangles, we need
          to do it now (we cannot wait the end of the modifications where we
          will know the size we actually need).</li>
          <li>Moving a triangle suppose the copy of data from buffer to buffer, gpu-side,
          which require that your implementation of webGL supports such operation.</li>
        </ul>
      The second problem can be mitigated by using an asynchronous system,
      where a thread a responsible for the actual sending. This solution only
      works partially as you will still have to wait for the completion the operations,
      as a whole, to do the rendering.
      </li>

      <li>
        Store a sparse array on the CPU, that will contain only modified areas.<br />
        Then, before rendering, transform the modifications into "segments of modifications",
        and only send those segments.<br />
        Pros:
          <ul>
            <li>Only real modifications will be sent. If the same triangle is modified
            multiple times in a single frame, only the final state of the triangle
            will be sent. </li>
            <li>Modifications on contiguous triangles will turn into a single segment
            and, therefore, a single message.</li>
            <li>If only a small number of modifications is done each frame, the
            memory usage CPU-side will remain low.</li>
          </ul>
        Cons:
          <ul>
            <li>It's not that common for a single triangle to be updated multiple times
            in one frame.</li>
            <li>It may happen, especially during the initialization, that a lot
            of modifications will happen during one frame. In that case, it'll
            create a huge sparse array on the cpu, containing maybe as many entries as the
            final number of triangles (if the scene won't be modified after),
            and, because it's a sparse array, it will be heavier than a regular array of the same
            size.</li>
            <li>Displacement of a triangle still requires the GPU doing it, as the information
            is not present CPU-side.</li>
          </ul>
        This second problem can be solved by implementing an "auto-flushing" stack
        of modifications, that will trigger its validation (and the reset of the sparse array),
        when there is too much pending modifications.<br />
        The third problem can be partially solved by retrieving the last triangles from the GPU.
        Triangles only move from the end of the buffer to other places, so its possible
        to complement the datas CPU-side in one call. However, you'll need the function
        getBufferSubData for this, and it's only available in WebGL2.
      </li>

      <li>
        Store a full copy of the datas CPU-side. Modifications will be applied
        immediatly on this copy of the datas, and we will mark each modified
        triangle and keep trace of the first and the last modified triangle.<br />

        For the validation of the modifications, the algorithm will be able to send
        segments containing unmodified data as well (so two segments can be merged into one
        if there is a small gap between them).
        Pros:
          <ul>
            <li>Can reduce the number of messages sent to an arbitrary number, possibly one.</li>
            <li>Separates entirely the modification of the data and the usage of the GL context,
            allowing for the logic of the game to take place in a separate thread where no GL
            context is available.</li>
          </ul>
        Cons:
          <ul>
            <li>Double the quantity of memory used.</li>
          </ul>
      </li>
    </ol>

    <p>As the management of the triangles is opaque for the rest of the program,
    switching from one solution to another should be easy (as long as the new solution
    is implemented, which can be hard).<br />
    For that reason, and because both the quantity of data per vertex and the quantity
    of vertices are low, I went with the third option. The first two options would require
    WebGL2 at some point anyway.</p>

    <p>What I said for triangles would work equally as well for quads or any other
    resources. For that reason, I'll sometime use the term "primitive" instead of triangle.</p>

<script class="visible_script">

function create_doom_vertex( position, texcoord )
{
  return { position: position, texcoord: texcoord };
}

function create_doom_triangle( A, B, C, sector, texture_id )
{
  return { A:A, B:B, C:C, sector:sector, texture_id:texture_id };
}

</script>

    <p>This is for the rest of the program, but internally triangles will
    be converted right away to their binary form:</p>

<script class="visible_script">


function convert_doom_triangle_to_binary( triangle, dv, position )
{
  function convert_doom_point_to_binary( point, dv, position )
  {
    dv.setInt16 ( position+0 , point.position.x );
    dv.setInt16 ( position+2 , point.position.y );
    dv.setInt16 ( position+4 , point.position.z );
    dv.setInt16 ( position+6 , point.texcoord.x );
    dv.setInt16 ( position+8 , point.texcoord.y );
    dv.setUint16( position+10, triangle.sector );
    dv.setUint16( position+12, triangle.texture_id );
  }

  convert_doom_point_to_binary( triangle.A, dv, position );
  convert_doom_point_to_binary( triangle.B, dv, position+14 );
  convert_doom_point_to_binary( triangle.C, dv, position+28 );
}

</script>



function create_primitive_access( mesh )
{
  var res;

  var nb_tickets_created = 0;
  var primitive_to_ticket = new Uint32Array( 10 ); // we will store unblackboxed tickets - i.e. indexes
  var ticket_to_primitive = new Uint32Array( 10 );
  var triangles

  var released_tickets = []; // we need pop/push actions on this one

  function blackboxify_ticket( number ) { return number+1; }
  function unblackboxify_ticket( ticket ) { return ticket-1; }
  function realloc( array, new_size )
  {
    var new_array = new Uint32Array( new_size );
    for ( var i = 0; i < array.length; i++ ) new_array[i] = array[i];
    // cannot free the old array *sigh*
    return new_array;
  }

  res.acquire_ticket = function()
  {
    if ( released_tickets.length == 0 )
    {
      released_tickets.push( blackboxify_ticket( nb_tickets_created ) );
      nb_tickets_created++;

      if ( nb_tickets_created > primitive_to_ticket.length )
      {
        var new_size = primitive_to_ticket.length * 1.3 + 1;
        primitive_to_ticket = realloc( primitive_to_ticket, new_size );
        ticket_to_primitive = realloc( ticket_to_primitive, new_size );
      }
    }

    var ticket = released_tickets.pop();
    var nb_primitives_in_use = nb_tickets_created - released_tickets.length;

    var index_of_the_last_primitive = nb_primitives_in_use-1;
    var index_of_the_ticket = unblackboxify_ticket( ticket );

    primitive_to_ticket[index_of_the_last_primitive] = index_of_the_ticket;
    ticket_to_primitive[index_of_the_ticket] = index_of_the_last_primitive;
  }

  res.release_ticket = function( ticket )
  {
    var nb_primitives_in_use = nb_tickets_created - released_tickets.length;

    var index_of_the_last_primitive = nb_primitives_in_use-1;
    var index_of_the_released_ticket = unblackboxify_ticket( ticket );
    var index_of_the_released_primitive = ticket_to_primitive[index_of_the_released_ticket];



    released_tickets.push( ticket );
  }


  return res;
}
</script>


    <h1>FIN</h1>










































<!--
      function opt_pixmap( w, h )
      {
        var res = { w: w, h: h, pixels: new Uint16Array( w*h ) };
        res.set = function( x, y, p ) { res.pixels[y*w+x] = (0x100)|p; }
        res.toImageData = function( palette )
        {
          var id = new ImageData( w, h );
          var d = id.data;
          for ( var p = 0; p < w*h; p++ )
          {
            var v = res.pixels[p];
            if ( v < 256 ) return;
            v -= 256;
            var rgb = palette[v];

            d[p*4]  = rgb.r;
            d[p*4+1]= rgb.g;
            d[p*4+2]= rgb.b;
            d[p*4+3]= 255;
          }
          return id;
        }
        return res;
      }
-->

    </div>
    </div>



  <script>

  var next_id = 0;

  function build_menus( element, out )
  {
    var name = element.tagName;
    switch( name )
    {
      case "H1":
      case "H2":
      case "H3":
      case "H4":
      case "H5":
      case "H6":
      {
        var a = document.createElement("a");
        a.textContent = element.textContent;
        a.className = element.tagName;

        if ( element.id == "" )
        {
          element.id = "anchor_menu_n_"+next_id;
          next_id++;
        }

        a.href = "#"+element.id;

        out.appendChild( a );
      }
    }

    var children = element.children;
    for ( var k in children )
      build_menus( children[k], out );
  }

  build_menus( document.body, document.getElementsByClassName("side_menus")[0] );

  var visible_scripts = document.getElementsByClassName("visible_script");
  while( visible_scripts.length > 0 )
  {
    var script = visible_scripts[0];
    script.className = "";

    var new_script = js_colorize( script.textContent );
    script.parentElement.insertBefore( new_script, script );
  }

  var glsl_scripts = document.getElementsByClassName("glsl_script");
  while( glsl_scripts.length > 0 )
  {
    var script = glsl_scripts[0];
    script.className = "";
    script.style.display = "none";

    var new_script = glsl_colorize( script.textContent );
    script.parentElement.insertBefore( new_script, script );
  }



  </script>
  </body>
</html>
